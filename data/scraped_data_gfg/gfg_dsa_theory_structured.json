[
  {
    "topic_name": "2. Learn about Complexities",
    "main_article_link": "https://www.geeksforgeeks.org/design-and-analysis-of-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "Order of Growth",
        "subtopic_url": "https://www.geeksforgeeks.org/order-o-f-growth/?preview_id=1347138&preview=true",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Why is Analysis of Algorithm important?",
        "subtopic_url": "https://www.geeksforgeeks.org/what-is-algorithm-and-why-analysis-of-it-is-important/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Worst, Average and Best Case Analysis of Algorithms",
        "subtopic_url": "https://www.geeksforgeeks.org/worst-average-and-best-case-analysis-of-algorithms/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "1. Worst Case Analysis (Mostly used)",
            "content": "In the worst-case analysis, we calculate the upper bound on the running time of an algorithm. We must know the case that causes a maximum number of operations to be executed.\nFor Linear Search, the worst case happens when the element to be searched (x) is not present in the array. When x is not present, the search() function compares it with all the elements of arr[] one by one.\nThis is the most commonly used analysis of algorithms (We will be discussing below why). Most of the time we consider the case that causes maximum operations.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Best Case Analysis (Very Rarely used)",
            "content": "In the best-case analysis, we calculate the lower bound on the running time of an algorithm. We must know the case that causes a minimum number of operations to be executed.\nFor linear search, the best case occurs when x is present at the first location. The number of operations in the best case is constant (not dependent on n). So the order of growth of time taken in terms of input size is constant.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Average Case Analysis (Rarely used)",
            "content": "In average case analysis, we take all possible inputs and calculate the computing time for all of the inputs. Sum all the calculated values and divide the sum by the total number of inputs.\nWe must know (or predict) the distribution of cases. For the linear search problem, let us assume that all cases are uniformly distributed (including the case of x not being present in the array). So we sum all the cases and divide the sum by (n+1). We take (n+1) to consider the case when the element is not present.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why is Worst Case Analysis Mostly Used?",
            "content": "Average Case : The average case analysis is not easy to do in most practical cases and it is rarely done. In the average case analysis, we need to consider every input, its frequency and time taken by it which may not be possible in many scenarios\nBest Case : The Best Case analysis is considered bogus. Guaranteeing a lower bound on an algorithm doesn’t provide any information as in the worst case, an algorithm may take years to run.\nWorst Case: This is easier than average case and gives an upper bound which is useful information to analyze software products.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Interesting information about asymptotic notations:",
            "content": "A) For some algorithms, all the cases (worst, best, average) are asymptotically the same. i.e., there are no worst and best cases. \nExample:  Merge Sort does order of n log(n) operations in all cases.\nB) Where as most of the other sorting algorithms have worst and best cases. \nExample 1: In the typical implementation of Quick Sort (where pivot is chosen as a corner element), the worst occurs when the input array is already sorted and the best occurs when the pivot elements always divide the array into two halves.\nExample 2: For insertion sort, the worst case occurs when the array is reverse sorted and the best case occurs when the array is sorted in the same order as output.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Examples with their complexity analysis:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Linear search algorithm:",
            "content": "Best Case: Constant Time irrespective of input size. This will take place if the element to be searched is on the first index of the given list. So, the number of comparisons, in this case, is 1.\nAverage Case: Linear Time, This will take place if the element to be searched is at the middle index (in an average search) of the given list.\nWorst Case: The element to be searched is not present in the list\n2. Special Array Sum : In this example, we will take an array of length (n) and deals with the following cases :\nIf (n) is even then our output will be 0\nIf (n) is odd then our output will be the sum of the elements of the array.\nBelow is the implementation of the given problem:\nTime Complexity Analysis:\nBest Case: The order of growth will be constant because in the best case we are assuming that (n) is even.\nAverage Case: In this case, we will assume that even and odd are equally likely, therefore Order of growth will be linear\nWorst Case: The order of growth will be linear because in this case, we are assuming that (n) is always odd.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Next Articles to Read",
            "content": "Asymptotic Notations\nAnalysis of Loops\nAnalysis of Recursive Functions\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Reference books:",
            "content": "“Introduction to Algorithms” by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein is a comprehensive guide to algorithm analysis, including worst, average, and best case analysis.\n“Algorithm Design” by Jon Kleinberg and Éva Tardos provides a modern approach to algorithm design, with a focus on worst case analysis.\n“The Art of Computer Programming” by Donald Knuth is a classic text on algorithms and programming, which includes a detailed discussion of worst case analysis.\n“Algorithms Unlocked” by Thomas H. Cormen provides a gentle introduction to algorithm analysis, including worst, average, and best case analysis.\n",
            "code_snippets": {
              "cpp": "#include <iostream>#include <vector>using namespace std;int getSum(const vector<int>& arr1) {    int n = arr1.size();    if (n % 2 == 0) // (n) is even        return 0;        int sum = 0;    for (int i = 0; i < n; i++) {        sum += arr1[i];    }    return sum; // (n) is odd}int main() {      // Declaring two vectors, one with an odd length    // and the other with an even length    vector<int> arr1 = {1, 2, 3, 4};    vector<int> arr2 = {1, 2, 3, 4, 5};    cout << getSum(arr1) << endl;     cout << getSum(arr2) << endl;    return 0;}",
              "c": "#include <stdio.h>#include <stdlib.h>int getSum(const int* arr1, int n) {    if (n % 2 == 0) // (n) is even        return 0;        int sum = 0;    for (int i = 0; i < n; i++) {        sum += arr1[i];    }    return sum; // (n) is odd}int main() {    // Declaring two arrays, one with an odd length    // and the other with an even length    int arr1[] = {1, 2, 3, 4};    int arr2[] = {1, 2, 3, 4, 5};    printf(\"%d\\n\", getSum(arr1, 4));    printf(\"%d\\n\", getSum(arr2, 5));    return 0;}",
              "java": "import java.util.Arrays;public classMain {    public static int getSum(int[] arr1) {        int n = arr1.length;        if (n % 2 == 0) // (n) is even            return 0;                int sum = 0;        for (int i = 0; i < n; i++) {            sum += arr1[i];        }        return sum; // (n) is odd    }    public static void main(String[] args) {        // Declaring two arrays, one with an odd length        // and the other with an even length        int[] arr1 = {1, 2, 3, 4};        int[] arr2 = {1, 2, 3, 4, 5};        System.out.println(getSum(arr1));        System.out.println(getSum(arr2));    }}",
              "python3": "defgetSum(arr1):n=len(arr1)ifn%2==0:# (n) is evenreturn0sum=0foriinrange(n):sum+=arr1[i]returnsum# (n) is oddif__name__=='__main__':# Declaring two lists, one with an odd length# and the other with an even lengtharr1=[1,2,3,4]arr2=[1,2,3,4,5]print(getSum(arr1))print(getSum(arr2))",
              "csharp": "using System;class Program {    static int getSum(int[] arr1) {        int n = arr1.Length;        if (n % 2 == 0) // (n) is even            return 0;                int sum = 0;        for (int i = 0; i < n; i++) {            sum += arr1[i];        }        return sum; // (n) is odd    }    static void Main() {        // Declaring two arrays, one with an odd length        // and the other with an even length        int[] arr1 = {1, 2, 3, 4};        int[] arr2 = {1, 2, 3, 4, 5};        Console.WriteLine(getSum(arr1));        Console.WriteLine(getSum(arr2));    }}",
              "javascript": "function getSum(arr1) {    const n = arr1.length;    if (n % 2 === 0) // (n) is even        return 0;        let sum = 0;    for (let i = 0; i < n; i++) {        sum += arr1[i];    }    return sum; // (n) is odd}// Declaring two arrays, one with an odd length// and the other with an even lengthconst arr1 = [1, 2, 3, 4];const arr2 = [1, 2, 3, 4, 5];console.log(getSum(arr1));console.log(getSum(arr2));",
              "php": "<?phpfunctiongetSum($arr1){$n=count($arr1);if($n%2==0)// (n) is evenreturn0;$sum=0;for($i=0;$i<$n;$i++){$sum+=$arr1[$i];}return$sum;// (n) is odd}// Declaring two arrays, one with an odd length// and the other with an even length$arr1=[1,2,3,4];$arr2=[1,2,3,4,5];echogetSum($arr1).\"\\n\";echogetSum($arr2).\"\\n\";?>"
            }
          }
        ]
      },
      {
        "subtopic_title": "Asymptotic Analysis",
        "subtopic_url": "https://www.geeksforgeeks.org/asymptotic-notation-and-analysis-based-on-input-size-of-algorithms/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Does Asymptotic Analysis always work?",
            "content": "Asymptotic Analysis is not perfect, but that's the best way available for analyzing algorithms. For example, say there are two sorting algorithms that take 1000nLogn and 2nLogn time respectively on a machine. Both of these algorithms are asymptotically the same (order of growth is nLogn). So, With Asymptotic Analysis, we can't judge which one is better as we ignore constants in Asymptotic Analysis. For example, asymptotically Heap Sort is better than Quick Sort, but Quick Sort takes less time in practice.\nAlso, in Asymptotic analysis, we always talk about input sizes larger than a constant value. It might be possible that those large inputs are never given to your software and an asymptotically slower algorithm always performs better for your particular situation. So, you may end up choosing an algorithm that is Asymptotically slower but faster for your software.\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "3. Array",
    "main_article_link": "https://www.geeksforgeeks.org/array-data-structure-guide/",
    "subtopics": [
      {
        "subtopic_title": "Getting Started with Array Data Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-arrays-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Basic terminologies of Array",
            "content": "Array Index: In an array, elements are identified by their indexes. Array index starts from 0.\nArray element: Elements are items stored in an array and can be accessed by their index.\nArray Length: The length of an array is determined by the number of elements it can contain.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Memory representation of Array",
            "content": "In an array, all the elements are stored in contiguous memory locations. So, if we initialize an array, the elements will be allocated sequentially in memory. This allows for efficient access and manipulation of elements.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Declaration of Array",
            "content": "Arrays can be declared in various ways in different languages. For better illustration, below are some language-specific array declarations:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Initialization of Array",
            "content": "Arrays can be initialized in different ways in different languages. Below are some language-specific array initializations:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why do we Need Arrays?",
            "content": "Assume there is a class of five students and if we have to keep records of their marks in examination then, we can do this by declaring five variables individual and keeping track of records but what if the number of students becomes very large, it would be challenging to manipulate and maintain the data.\nWhat it means is that, we can use normal variables (v1, v2, v3, ..) when we have a small number of objects. But if we want to store a large number of instances, it becomes difficult to manage them with normal variables.\nThe idea of an array is to represent many instances in one variable.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Arrays",
            "content": "Arrays can be classified in two ways:\nOn the basis of Size\nOn the basis of Dimensions\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Arrays on the basis of Size",
            "content": "1. Fixed Sized Arrays\nWe cannot alter or update the size of this array. Here only a fixed size (i,e. the size that is mentioned in square brackets []) of memory will be allocated for storage. In case, we don't know the size of the array then if we declare a larger size and store a lesser number of elements will result in a wastage of memory or we declare a lesser size than the number of elements then we won't get enough memory to store all the elements. In such cases, static memory allocation is not preferred.\n2. Dynamic Sized Arrays\nThe size of the array changes as per user requirements during execution of code so the coders do not have to worry about sizes. They can add and removed the elements as per the need. The memory is mostly dynamically allocated and de-allocated in these arrays.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Arrays on the basis of Dimensions",
            "content": "1. One-dimensional Array(1-D Array): You can imagine a 1d array as a row, where elements are stored one after another.\n2. Multi-dimensional Array: A multi-dimensional array is an array with more than one dimension. We can use multidimensional array to store complex data in the form of tables, etc. We can have 2-D arrays, 3-D arrays, 4-D arrays and so on.\nTwo-Dimensional Array(2-D Array or Matrix): 2-D Multidimensional arrays can be considered as an array of arrays or as a matrix consisting of rows and columns.\nTo read more about Matrix Refer, Matrix Data Structure\nThree-Dimensional Array(3-D Array): A 3-D Multidimensional array contains three dimensions, so it can be considered an array of two-dimensional arrays.\nTo read more about Multidimensional Array Refer, Multidimensional Arrays in C – 2D and 3D Arrays\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operations on Array",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Array Traversal",
            "content": "Array traversal refers to the process of accessing and processing each element of an array sequentially. This is one of the most fundamental operations in programming, as arrays are widely used data structures for storing multiple elements in a single variable.\nHow Array Traversal Works?\nWhen an array is created, it occupies a contiguous block of memory where elements are stored in an indexed manner. Each element can be accessed using its index, which starts from 0 in most programming languages.\nFor example, consider an array containing five integers:\narr = [10, 20, 30, 40, 50]\nHere:\nThe first element (10) is at index 0.\nThe second element (20) is at index 1.\nThe last element (50) is at index 4.\nArray traversal means accessing each element from start to end (or sometimes in reverse order), usually by using a loop.\nTypes of Array Traversal\nArray traversal can be done in multiple ways based on the requirement:\nSequential (Linear) Traversal\nThis is the most common way of traversing an array.\nIt involves iterating through the array one element at a time from the first index to the last.\nUsed for printing elements, searching, or performing calculations (such as sum or average).\nReverse Traversal\nInstead of starting from index 0, the traversal begins from the last element and moves towards the first.\nThis is useful in cases where we need to process elements from the end.\nTo read more about Array Traversal Refer, Traversal in Array\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Insertion in Array",
            "content": "Insertion in an array refers to the process of adding a new element at a specific position while maintaining the order of the existing elements. Since arrays have a fixed size in static implementations, inserting an element often requires shifting existing elements to make space.\nHow Insertion Works in an Array?\nArrays are stored in contiguous memory locations, meaning elements are arranged in a sequential block. When inserting a new element, the following happens:\nIdentify the Position: Determine where the new element should be inserted.\nShift Elements: Move the existing elements one position forward to create space for the new element.\nInsert the New Element: Place the new value in the correct position.\nUpdate the Size (if applicable): If the array is dynamic, its size is increased.\nFor example, if we have the array:\narr = [10, 20, 30, 40, 50]\nand we want to insert 25 at index 2, the new array will be:\narr = [10, 20, 25, 30, 40, 50]\nHere, elements 30, 40, and 50 have shifted right to make space.\nTypes of Insertion\n1. Insertion at the Beginning (Index 0)\nEvery element must shift one position right.\nThis is the least efficient case for large arrays as it affects all elements.\n2. Insertion at a Specific Index\nElements after the index shift right.\nIf the index is in the middle, half of the array moves.\n3. Insertion at the End\nThe simplest case since no shifting is required.\nUsed in dynamic arrays where size increases automatically (e.g., Python lists, Java ArrayList).\nTo read more about Insertion in Array Refer, Inserting Elements in an Array – Array Operations\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Deletion in Array",
            "content": "Deletion in an array refers to the process of removing an element from a specific position while maintaining the order of the remaining elements. Unlike linked lists, where deletion is efficient, removing an element from an array requires shifting elements to fill the gap.\nHow Deletion Works in an Array?\nSince arrays have contiguous memory allocation, deleting an element does not reduce the allocated memory size. Instead, it involves:\nIdentify the Position: Find the index of the element to be deleted.\nShift Elements: Move the elements after the deleted element one position to the left.\nUpdate the Size (if applicable): If using a dynamic array, the size might be reduced.\nFor example, consider the array:\narr = [10, 20, 30, 40, 50]\nIf we delete the element 30 (index 2), the new array will be:\narr = [10, 20, 40, 50]\nHere, elements 40 and 50 shifted left to fill the gap.\nTypes of Deletion\n1. Deletion at the Beginning (Index 0)\nEvery element shifts left by one position.\nThis is the most expensive case as it affects all elements.\n2. Deletion at a Specific Index\nOnly elements after the index shift left.\nIf the index is in the middle, half of the array moves.\n3. Deletion at the End\nThe simplest case since no shifting is required.\nThe size of the array is reduced (in dynamic arrays).\nTo read more about Deletion in Array Refer, Deleting Elements in an Array – Array Operations\n4. Searching in Array\nSearching in an array refers to the process of finding a specific element in a given list of elements. The goal is to determine whether the element exists in the array and, if so, find its index (position).\nSearching is a fundamental operation in programming, as it is used in data retrieval, filtering, and processing.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Searching in an Array",
            "content": "There are two main types of searching techniques in an array:\n1. Linear Search (Sequential Search)\nThis is the simplest search algorithm.\nIt traverses the array one element at a time and compares each element with the target value.\nIf a match is found, it returns the index of the element.\nIf the element is not found, the search continues until the end of the array.\nConsider an array:\narr = [10, 20, 30, 40, 50]\nIf we search for 30, the algorithm will:\nCompare 10 with 30 → No match.\nCompare 20 with 30 → No match.\nCompare 30 with 30 → Match found at index 2.\n2. Binary Search (Efficient Search for Sorted Arrays)\nWorks only on sorted arrays (in increasing or decreasing order).\nUses a divide and conquer approach.\nIt repeatedly divides the search space in half until the target element is found.\nFind the middle element of the array.\nIf the target is equal to the middle element, return its index.\nIf the target is less than the middle element, search the left half.\nIf the target is greater than the middle element, search the right half.\nRepeat until the element is found or the search space is empty.\nConsider a sorted array:\narr = [10, 20, 30, 40, 50]\nIf we search for 30:\nMiddle element = 30 → Match found!\nThe search ends in just one step, making it much faster than linear search.\nTo read more about Searching in Array Refer, Searching Elements in Array\nNext Read: Applications, Advantages and Disadvantages of Array\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Related articles:",
            "content": "Top 50 Array Coding Problems for Interviews\nHow to start learning DSA?\nCompetitive Programming – A Complete Guide\nHow can one become good at Data Structures and Algorithms easily?\nWhy Data Structures and Algorithms Are Important to Learn?\nTop 15 Websites for Coding Challenges and competitions\nSDE SHEET – A Complete Guide for SDE Preparation\nAmazon SDE Sheet – A Guide for Amazon SDE Interview Preparation\nGoogle Interview Preparation For Software Engineer – A Complete Guide\n100 Days of Code – A Complete Guide For Beginners and Experienced\n",
            "code_snippets": {
              "cpp": "#include<vector>// Dynamic Integer Arrayvector<int> v;",
              "c": "// C does not seem to support// dynamic sized arrays as of now",
              "java": "// Dynamic Integer ArrayArrayList<Integer> arr = new ArrayList<>();",
              "python3": "# Dynamic Arrayarr=[]",
              "csharp": "// Similar to JavaArrayList myList = new ArrayList();",
              "javascript": "// Dynamic Sized Arraylet arr = new Array();"
            }
          }
        ]
      },
      {
        "subtopic_title": "Applications, Advantages and Disadvantages of Array",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-array-data-structure/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Applications of Array Data Structure:",
            "content": "Arrays mainly have advantages like random access and cache friendliness over other data structures that make them useful.\nBelow are some applications of arrays.\nStoring and accessing data: Arrays store elements in a specific order and allow constant-time O(1) access to any element.\nSearching: If data in array is sorted, we can search an item in O(log n) time. We can also find floor(), ceiling(), kth smallest, kth largest, etc efficiently.\nMatrices: Two-dimensional arrays are used for matrices in computations like graph algorithms and image processing.\nImplementing other data structures: Arrays are used as the underlying data structure for implementing stacks and queues.\nDynamic programming: Dynamic programming algorithms often use arrays to store intermediate results of subproblems in order to solve a larger problem.\nData Buffers: Arrays serve as data buffers and queues, temporarily storing incoming data like network packets, file streams, and database results before processing.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Array Data Structure:",
            "content": "Efficient and Fast Access: Arrays allow direct and efficient access to any element in the collection with constant access time, as the data is stored in contiguous memory locations.\nMemory Efficiency: Arrays store elements in contiguous memory, allowing efficient allocation in a single block and reducing memory fragmentation.\nVersatility: Arrays can be used to store a wide range of data types, including integers, floating-point numbers, characters, and even complex data structures such as objects and pointers.\nCompatibility with hardware: The array data structure is compatible with most hardware architectures, making it a versatile tool for programming in a wide range of environments.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Array Data Structure:",
            "content": "Fixed Size: Arrays have a fixed size set at creation. Expanding an array requires creating a new one and copying elements, which is time-consuming and memory-intensive.\nMemory Allocation Issues: Allocating large arrays can cause memory exhaustion, leading to crashes, especially on systems with limited resources.\nInsertion and Deletion Challenges: Adding or removing elements requires shifting subsequent elements, making these operations inefficient.\nLimited Data Type Support: Arrays support only elements of the same type, limiting their use with complex data types.\nLack of Flexibility: Fixed size and limited type support make arrays less adaptable than structures like linked lists or trees.\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "5. Sorting Algorithm",
    "main_article_link": "https://www.geeksforgeeks.org/sorting-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "Applications, Advantages and Disadvantages of Sorting Algorithm",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-sorting-algorithm/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Applications of Sorting Algorithms:",
            "content": "Quickly Finding k-th Smallest or K-th Largest : Once we sort the array, we can find k-th smallest and k-th largest elements in O(1) time for different values of k.\nSearching Algorithms: Sorting is often a crucial step in search algorithms like binary search, Ternary Search, where the data needs to be sorted before searching for a specific element.\nData management: Sorting data makes it easier to search, retrieve, and analyze.\nDatabase optimization: Sorting data in databases improves query performance. We typically keep the data sorted by primary index so that we can do quick queries.\nMachine learning: Sorting is used to prepare data for training machine learning models.\nData Analysis: Sorting helps in identifying patterns, trends, and outliers in datasets. It plays a vital role in statistical analysis, financial modeling, and other data-driven fields.\nOperating Systems: Sorting algorithms are used in operating systems for tasks like task scheduling, memory management, and file system organization.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Sorting Algorithms:",
            "content": "Efficiency: Sorting algorithms help in arranging data in a specific order, making it easier and faster to search, retrieve, and analyze information.\nImproved Performance: By organizing data in a sorted manner, algorithms can perform operations more efficiently, leading to improved performance in various applications.\nSimplified data analysis: Sorting makes it easier to identify patterns and trends in data.\nReduced memory consumption: Sorting can help reduce memory usage by eliminating duplicate elements.\nImproved data visualization: Sorted data can be visualized more effectively in charts and graphs.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Sorting Algorithms:",
            "content": "Insertion: If we wish to keep data sorted, then insertion operation becomes costly as we have to maintain sorted order. If we do not have to maintain sorted order, we can simply insert at the end.\nAlgorithm selection: Choosing the most appropriate sorting algorithm for a given dataset can be challenging.\nFor a lot of problems hashing works better than sorting, for example, finding distinct elements, finding a pair with given sum.\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Introduction to Sorting Techniques – Data Structure and Algorithm Tutorials",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-sorting-algorithm/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Why Sorting Algorithms are Important",
            "content": "The sorting algorithm is important in Computer Science because it reduces the complexity of a problem. There is a wide range of applications for these algorithms, including searching algorithms, database algorithms, divide and conquer methods, and data structure algorithms.\nIn the following sections, we list some important scientific applications where sorting algorithms are used\nWhen you have hundreds of datasets you want to print, you might want to arrange them in some way.\nOnce we get the data sorted, we can get the k-th smallest and k-th largest item in O(1) time.\nSearching any element in a huge data set becomes easy. We can use Binary search method for search if we have sorted data. So, Sorting become important here.\nThey can be used in software and in conceptual problems to solve more advanced problems.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Sorting Basics",
            "content": "In-place Sorting: An in-place sorting algorithm uses constant space for producing the output (modifies the given array only. Examples: Selection Sort, Bubble Sort, Insertion Sort and Heap Sort.\nInternal Sorting: Internal Sorting is when all the data is placed in the main memory or internal memory. In internal sorting, the problem cannot take input beyond allocated memory size.\nExternal Sorting : External Sorting is when all the data that needs to be sorted need not to be placed in memory at a time, the sorting is called external sorting. External Sorting is used for the massive amount of data. For example Merge sort can be used in external sorting as the whole array does not have to be present all the time in memory,\nStable sorting: When two same items appear in the same order in sorted data as in the original array called stable sort. Examples: Merge Sort, Insertion Sort, Bubble Sort.\nHybrid Sorting: A sorting algorithm is called Hybrid if it uses more than one standard sorting algorithms to sort the array. The idea is to take advantages of multiple sorting algorithms. For example IntroSort uses Insertions sort and Quick Sort.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Sorting Techniques",
            "content": "There are various sorting algorithms are used in data structures. The following two types of sorting algorithms can be broadly classified:\nComparison-based: We compare the elements in a comparison-based sorting algorithm)\nNon-comparison-based: We do not compare the elements in a non-comparison-based sorting algorithm)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Some of the most common sorting algorithms are:",
            "content": "Selection sort, Bubble sort, Insertion Sort, Cycle Sort, Merge Sort, 3-way Merge Sort, Quick sort, Heap sort and Counting sort\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Some other Sorting algorithms:",
            "content": "Radix sort, Bucket sort, Shell sort, Tim Sort, Comb Sort, Pigeonhole sorting, Cocktail Sort, Strand sort, Bitonic Sort, Stooge Sort, Tag Sort, Tree sort, Cartesian Sort, Odd-Even Sort / Brick Sort, Gnome sort, Cocktail shaker sort\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Comparison of Complexity Analysis of Sorting Algorithms:",
            "content": "",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "6. Hashing",
    "main_article_link": "https://www.geeksforgeeks.org/hashing-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Separate Chaining Collision Handling Technique in Hashing",
        "subtopic_url": "https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Separate Chaining:",
            "content": "The idea behind separate chaining is to implement the array as a linked list called a chain.\nLinked List (or a Dynamic Sized Array) is used to implement this technique. So what happens is, when multiple elements are hashed into the same slot index, then these elements are inserted into a singly-linked list which is known as a chain.\nHere, all those elements that hash into the same slot index are inserted into a linked list. Now, we can use a key K to search in the linked list by just linearly traversing. If the intrinsic key for any entry is equal to K then it means that we have found our entry. If we have reached the end of the linked list and yet we haven’t found our entry then it means that the entry does not exist. Hence, the conclusion is that in separate chaining, if two different elements have the same hash value then we store both the elements in the same linked list one after the other.\n\nExample: Let us consider a simple hash function as “key mod 5” and a sequence of keys as 12, 22, 15, 25\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation",
            "content": "Please refer Program for hashing with chaining for implementation.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages:",
            "content": "Simple to implement. \nHash table never fills up, we can always add more elements to the chain. \nLess sensitive to the hash function or load factors. \nIt is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages:",
            "content": "The cache performance of chaining is not good as keys are stored using a linked list. Open addressing provides better cache performance as everything is stored in the same table. \nWastage of Space (Some Parts of the hash table are never used) \nIf the chain becomes long, then search time can become O(n) in the worst case\nUses extra space for links\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Performance of Chaining:",
            "content": "Performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of the table (simple uniform hashing).\nm = Number of slots in hash table\nn = Number of keys to be inserted in hash table\nLoad factor α = n/m\nExpected time to search = O(1 + α)\nExpected time to delete = O(1 + α)\nTime to insert = O(1)\nTime complexity of search insert and delete is O(1) if  α is O(1)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Data Structures For Storing Chains:",
            "content": "Below are different options to create chains.\nThe advantage of linked list implementation is insert is O(1) in the worst case.\nThe advantage of array is cache friendliness, but the insert operation can be O(1) in cases when we have to resize the array.\nThe advantage of Self Balancing BST is the worst case is bounded by O(Log (len)) for all operations\n1. Linked lists\nSearch: O(len) where len = length of chain\nDelete: O(len)\nInsert: O(1)\nNot cache friendly\n2. Dynamic Sized Arrays ( Vectors in C++, ArrayList in Java, list in Python)\nSearch: O(len) where len = length of chain\nDelete: O(len)\nInsert: O(l)\nCache friendly\n3. Self Balancing BST ( AVL Trees, Red-Black Trees)\nSearch: O(log(len)) where len = length of chain\nDelete: O(log(len))\nInsert: O(log(len))\nNot cache friendly\nJava 8 onward versions use this for HashMap\nRelated Posts:\nOpen Addressing for Collision Handling \nHashing | Set 1 (Introduction)\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Introduction to Hashing",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Hash Table Data Structure Overview",
            "content": "It is one of the most widely used data structure after arrays.\nIt mainly supports search, insert and delete in O(1) time on average which is more efficient than other popular data structures like arrays, Linked List and Self Balancing BST.\nWe use hashing for dictionaries, frequency counting, maintaining data for quick access by key, etc.\nReal World Applications include Database Indexing, Cryptography, Caches, Symbol Table and Dictionaries.\nThere are mainly two forms of hash typically implemented in programming languages.\nHash Set : Collection of unique keys (Implemented as Set in Python, Set in JavaScrtipt, unordered_set in C++ and HashSet in Java.\nHash Map : Collection of key value pairs with keys being unique (Implemented as dictionary in Python, Map in JavaScript, unordered_map in C++ and HashMap in Java)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Situations Where Hash is not Used",
            "content": "Need to maintain sorted data along with search, insert and delete. We use a self balancing BST in these cases.\nWhen Strings are keys and we need operations like prefix search along with search, insert and delete. We use Trie in these cases.\nWhen we need operations like floor and ceiling along with search, insert and/or delete. We use Self Balancing BST in these cases.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Components of Hashing",
            "content": "There are majorly three components of hashing:\nKey: A Key can be anything string or integer which is fed as input in the hash function the technique that determines an index or location for storage of an item in a data structure.\nHash Function: Receives the input key and returns the index of an element in an array called a hash table. The index is known as the hash index .\nHash Table: Hash table is typically an array of lists. It stores values corresponding to the keys. Hash stores the data in an associative manner in an array where each data value has its own unique index.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How does Hashing work?",
            "content": "Suppose we have a set of strings {“ab”, “cd”, “efg”} and we would like to store it in a table.\nStep 1: We know that hash functions (which is some mathematical formula) are used to calculate the hash value which acts as the index of the data structure where the value will be stored.\nStep 2: So, let's assign\n“a” = 1,\n“b”=2, .. etc, to all alphabetical characters.\nStep 3: Therefore, the numerical value by summation of all characters of the string:\n“ab” = 1 + 2 = 3, \n “cd” = 3 + 4 = 7 , \n “efg” = 5 + 6 + 7 = 18\nStep 4: Now, assume that we have a table of size 7 to store these strings. The hash function that is used here is the sum of the characters in key mod Table size . We can compute the location of the string in the array by taking the sum(string) mod 7 .\nStep 5: So we will then store\n“ab” in 3 mod 7 = 3,\n“cd” in 7 mod 7 = 0, and\n“efg” in 18 mod 7 = 4.\nThe above technique enables us to calculate the location of a given string by using a simple hash function and rapidly find the value that is stored in that location. Therefore the idea of hashing seems like a great way to store (key, value) pairs of the data in a table.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is a Hash function?",
            "content": "A hash function creates a mapping from an input key to an index in hash table, this is done through the use of mathematical formulas known as hash functions. For example: Consider phone numbers as keys and a hash table of size 100. A simple example hash function can be to consider the last two digits of phone numbers so that we have valid array indexes as output. A good hash function should have the following properties:\nEfficient\nShould uniformly distribute the keys to each index of hash table.\nShould minimize collisions (This and the below are mainly derived from the above 2nd point)\nShould have a low load factor (number of items in the table divided by the size of the table).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is Collision in Hashing?",
            "content": "When two or more keys have the same hash value, a collision happens. If we consider the above example, the hash function we used is the sum of the letters, but if we examined the hash function closely then the problem can be easily visualised that for different strings same hash value is being generated by the hash function.\nFor example: {“ab”, “ba”} both have the same hash value, and string {“cd”,”be”} also generate the same hash value, etc. This is known as collision and it creates problem in searching, insertion, deletion, and updating of value.\nThe probability of a hash collision depends on the size of the algorithm, the distribution of hash values and the efficiency of Hash function. To handle this collision, we use Collision Resolution Techniques.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is meant by Load Factor in Hashing?",
            "content": "The load factor of the hash table can be defined as the number of items the hash table contains divided by the size of the hash table. Load factor is the decisive parameter that is used when we want to rehash the previous hash function or want to add more elements to the existing hash table.\nIt helps us in determining the efficiency of the hash function i.e. it tells whether the hash function which we are using is distributing the keys uniformly or not in the hash table.\nLoad Factor = Total elements in hash table/ Size of hash table\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is Rehashing?",
            "content": "As the name suggests, rehashing means hashing again. Basically, when the load factor increases to more than its predefined value (the default value of the load factor is 0.75), the complexity increases. So to overcome this, the size of the array is increased (doubled) and all the values are hashed again and stored in the new double-sized array to maintain a low load factor and low complexity.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How to Create Your Own Hash Table?",
            "content": "You Own Hash Table with Chaining\nYour Own Hash Table with Linear Probing in Open Addressing\nYour Own Hash Table with Quadratic Probing in Open Addressing\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Open Addressing Collision Handling technique in Hashing",
        "subtopic_url": "https://www.geeksforgeeks.org/hashing-set-3-open-addressing/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Different ways of Open Addressing:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1.",
            "content": "In linear probing, the hash table is searched sequentially that starts from the original location of the hash. If in case the location that we get is already occupied, then we check for the next location.\nThe function used for rehashing is as follows: rehash(key) = (n+1)%table-size.\nFor example, The typical gap between two probes is 1 as seen in the example below:\nLet hash(x) be the slot index computed using a hash function and S be the table size \nIf slot hash(x) % S is full, then we try (hash(x) + 1) % S\nIf (hash(x) + 1) % S is also full, then we try (hash(x) + 2) % S\nIf (hash(x) + 2) % S is also full, then we try (hash(x) + 3) % S\nExample: Let us consider a simple hash function as “key mod 5” and a sequence of keys that are to be inserted are 50, 70, 76, 85, 93.\nImplementation : Please refer Program to implement Hash Table using Open Addressing\n2. Quadratic Probing\nIf you observe carefully, then you will understand that the interval between probes will increase proportionally to the hash value. Quadratic probing is a method with the help of which we can solve the problem of clustering that was discussed above.  This method is also known as the mid-square method. In this method, we look for the i2'th slot in the ith iteration. We always start from the original hash location. If only the location is occupied then we check the other slots.\nlet hash(x) be the slot index computed using hash function.  \nIf slot hash(x) % S is full, then we try (hash(x) + 1*1) % S\nIf (hash(x) + 1*1) % S is also full, then we try (hash(x) + 2*2) % S\nIf (hash(x) + 2*2) % S is also full, then we try (hash(x) + 3*3) % S\nExample: Let us consider table Size = 7, hash function as Hash(x) = x % 7 and collision resolution strategy to be f(i) = i2 . Insert = 22, 30, and 50.\nImplementation : Please refer Program for Quadratic Probing in Hashing\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3.",
            "content": "The intervals that lie between probes are computed by another hash function. Double hashing is a technique that reduces clustering in an optimized way. In this technique, the increments for the probing sequence are computed by using another hash function. We use another hash function hash2(x) and look for the i*hash2(x) slot in the ith rotation.\nlet hash(x) be the slot index computed using hash function.  \nIf slot hash(x) % S is full, then we try (hash(x) + 1*hash2(x)) % S\nIf (hash(x) + 1*hash2(x)) % S is also full, then we try (hash(x) + 2*hash2(x)) % S\nIf (hash(x) + 2*hash2(x)) % S is also full, then we try (hash(x) + 3*hash2(x)) % S\nExample: Insert the keys 27, 43, 692, 72 into the Hash Table of size 7. where first hash-function is h1(k) = k mod 7 and second hash-function is h2(k) = 1 + (k mod 5)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Comparison of the above three:",
            "content": "Open addressing is a collision handling technique used in hashing where, when a collision occurs (i.e., when two or more keys map to the same slot), the algorithm looks for another empty slot in the hash table to store the collided key.\nIn linear probing, the algorithm simply looks for the next available slot in the hash table and places the collided key there. If that slot is also occupied, the algorithm continues searching for the next available slot until an empty slot is found. This process is repeated until all collided keys have been stored. Linear probing has the best cache performance but suffers from clustering. One more advantage of Linear probing is easy to compute. \nIn quadratic probing, the algorithm searches for slots in a more spaced-out manner. When a collision occurs, the algorithm looks for the next slot using an equation that involves the original hash value and a quadratic function. If that slot is also occupied, the algorithm increments the value of the quadratic function and tries again. This process is repeated until an empty slot is found. Quadratic probing lies between the two in terms of cache performance and clustering. \nIn double hashing, the algorithm uses a second hash function to determine the next slot to check when a collision occurs. The algorithm calculates a hash value using the original hash function, then uses the second hash function to calculate an offset. The algorithm then checks the slot that is the sum of the original hash value and the offset. If that slot is occupied, the algorithm increments the offset and tries again. This process is repeated until an empty slot is found.  Double hashing has poor cache performance but no clustering. Double hashing requires more computation time as two hash functions need to be computed.\nThe choice of collision handling technique can have a significant impact on the performance of a hash table. Linear probing is simple and fast, but it can lead to clustering (i.e., a situation where keys are stored in long contiguous runs) and can degrade performance. Quadratic probing is more spaced out, but it can also lead to clustering and can result in a situation where some slots are never checked. Double hashing is more complex, but it can lead to more even distribution of keys and can provide better performance in some cases.\nNote: Cache performance of chaining is not good because when we traverse a Linked List, we are basically jumping from one node to another, all across the computer's memory. For this reason, the CPU cannot cache the nodes which aren't visited yet, this doesn't help us. But with Open Addressing, data isn't spread, so if the CPU detects that a segment of memory is constantly being accessed, it gets cached for quick access.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Performance of Open Addressing:",
            "content": "Like Chaining, the performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of the table (simple uniform hashing)\nm = Number of slots in the hash table\nn = Number of keys to be inserted in the hash table\n Load factor α = n/m  ( < 1 )\nExpected time to search/insert/delete < 1/(1 - α) \nSo Search, Insert and Delete take (1/(1 - α)) time\nRelated Articles:\nHashing | Set 1 (Introduction)\nHashing | Set 2 (Separate Chaining)\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Applications of Hashing",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-of-hashing/",
        "sub_subtopics": []
      }
    ]
  },
  {
    "topic_name": "10. String",
    "main_article_link": "https://www.geeksforgeeks.org/string-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Introduction to Strings - Data Structure and Algorithm Tutorials",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-strings-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "How Strings are represented in Memory?",
            "content": "In C, a string can be referred to either using a character pointer or as a character array. When strings are declared as character arrays, they are stored like other types of arrays in C. String literals (assigned to pointers) are immutable in C and C++.\nIn C++, strings created using string class are mutable and internally represented as arrays. In Python, Java and JavaScript, strings characters are stored at contiguous locations (like arrays).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How to Declare Strings in various languages?",
            "content": "C: Strings are declared as character arrays or pointers and must end with a null character (\\0) to indicate termination.\nC++: Supports both C-style character arrays and the std::string class, which provides built-in functions for string manipulation.\nJava: Strings are immutable objects of the String class, meaning their values cannot be modified once assigned.\nPython: Strings are dynamic and can be declared using single, double, or triple quotes, making them flexible for multi-line text handling.\nJavaScript: Strings are primitive data types and can be defined using single, double, or template literals (backticks), allowing for interpolation.\nC#: Uses the string keyword, which represents an immutable sequence of characters, similar to Java.\nThere is no character type on Python and JavaScript and a single character is also considered as a string.\nBelow is the representation of strings in various languages:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Are Strings Mutable in Different Languages?",
            "content": "In C/C++, string literals (assigned to pointers) are immutable.\nIn C++, string objects are mutable.\nIn Python, Java and JavaScript, strings are immutable.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "General Operations performed on String",
            "content": "Here we are providing you with some must-know concepts of string:\nLength of String : The length of a string refers to the total number of characters present in it, including letters, digits, spaces, and special characters. It is a fundamental property of strings in any programming language and is often used in various operations such as validation, manipulation, and comparison.\nSearch a Character : Searching for a character in a string means finding the position where a specific character appears. If the character is present multiple times, you might need to find its first occurrence, last occurrence, or all occurrences.\nCheck for Substring : Checking for a substring means determining whether a smaller sequence of characters exists within a larger string. A substring is a continuous part of a string, and checking for its presence is a common operation in text processing, search algorithms, and data validation.\nInsert a Character : Inserting a character into a string means adding a new character at a specific position while maintaining the original order of other characters. Since strings are immutable in many programming languages, inserting a character usually involves creating a new modified string with the desired character placed at the specified position.\nDelete a Character : Deleting a character from a string means removing a specific character at a given position while keeping the remaining characters intact. Since strings are immutable in many programming languages, this operation usually involves creating a new string without the specified character.\nCheck for Same Strings : Checking if two strings are the same means comparing them character by character to determine if they are identical in terms of length, order, and content. If every character in one string matches exactly with the corresponding character in another string, they are considered the same.\nString Concatenation : String concatenation is the process of joining two or more strings together to form a single string. This is useful in text processing, formatting messages, constructing file paths, or dynamically creating content.\nReverse a String : Reversing a string means arranging its characters in the opposite order while keeping their original positions intact in the reversed sequence. This operation is commonly used in text manipulation, data encryption, and algorithm challenges.\nRotate a String Rotating a string means shifting its characters to the left or right by a specified number of positions while maintaining the order of the remaining characters. The characters that move past the boundary wrap around to the other side.\nCheck for Palindrome : Checking for a palindrome means determining whether a string reads the same forward and backward. A palindrome remains unchanged when reversed, making it a useful concept in text processing, algorithms, and number theory.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Introduction to Strings - Data Structure and Algorithm Tutorials - FAQs",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Is string a linear data structure?",
            "content": "Yes, string is a linear data structure.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Where are strings used?",
            "content": "It is used to store the sequence of characters.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Is string a data type?",
            "content": "A string is generally considered a data type and is often implemented as an array data structure of bytes (or words) that stores a sequence of elements, typically characters, using some character encoding.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why is text called string?",
            "content": "Text are also called string because it consists of sequence of characters like string.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What are characters in a string?",
            "content": "Each digit in a string is a character and character is a single visual object used to represent text, numbers, or symbols.\nSearch a Character\n",
            "code_snippets": {
              "cpp": "#include <iostream>using namespace std;int main() {    const char* str = \"Hello, world!\";    str[0] = 'h';  // Error : Assignment to read only    cout << str;    return 0;}",
              "c": "#include <stdio.h>int main() {    char *str = \"Hello, world!\";    str[0] = 'h';  // Undefined behavior    printf(\"%s\\n\", str);    return 0;}",
              "java": "// Java Program to demonstrate why// Java Strings are immutableimport java.io.*;classGfG {      public static void main(String[] args) {              String s1 = \"java\";             s1.concat(\" rules\");              // s1 is not changed because strings are        // immutable        System.out.println(\"s1 refers to \" + s1);    }}",
              "python": "# Python Program for# Creation of String# Creating a String# with single QuotesString1='Welcome to the Geeks World'print(\"String with the use of Single Quotes: \")print(String1)# Creating a String# with double QuotesString1=\"I'm a Geek\"print(\"\\nString with the use of Double Quotes: \")print(String1)# Creating a String# with triple QuotesString1='''I'm a Geek and I live in a world of \"Geeks\"'''print(\"\\nString with the use of Triple Quotes: \")print(String1)# Creating String with triple# Quotes allows multiple linesString1='''Geeks            For            Life'''print(\"\\nCreating a multiline String: \")print(String1)",
              "csharp": "// Include namespace systemusing System;public class Test{    public static void Main(String[] args)    {        // Declare String without using new operator        var s = \"GeeksforGeeks\";        // Prints the String.        Console.WriteLine(\"String s = \" + s);        // Declare String using new operator        var s1 = new  String(\"GeeksforGeeks\");        // Prints the String.        Console.WriteLine(\"String s1 = \" + s1);    }}",
              "javascript": "let str = \"GFG\";str[1] = \"f\"; console.log(str);    // Output: \"GFG\" (unchanged)",
              "php": "<?php// single-quote strings$site='Welcome to GeeksforGeeks';echo$site;?>",
              "python3": "# Create an immutable strings=\"GFG\"# This will cause a error # because strings are immutables[1]='f'print(s)"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "11. Recursion",
    "main_article_link": "https://www.geeksforgeeks.org/recursion-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "What is Tail Recursion",
        "subtopic_url": "https://www.geeksforgeeks.org/tail-recursion/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Need for Tail Recursion:",
            "content": "The tail recursive functions are considered better than non-tail recursive functions as tail-recursion can be optimized by the compiler.\nCompilers usually execute recursive procedures by using a stack. This stack consists of all the pertinent information, including the parameter values, for each recursive call. When a procedure is called, its information is pushed onto a stack, and when the function terminates the information is popped out of the stack. Thus for the non-tail-recursive functions, the stack depth (maximum amount of stack space used at any time during compilation) is more.\nThe idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current function's stack frame is of no use (See this for more details).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Can a non-tail-recursive function be written as tail-recursive to optimize it?",
            "content": "Consider the following function to calculate the factorial of n.\nIt is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we take a closer look, we can see that the value returned by fact(n-1) is used in fact(n). So the call to fact(n-1) is not the last thing done by fact(n).\nThe above function can be written as a tail-recursive function. The idea is to use one more argument and accumulate the factorial value in the second argument. When n reaches 0, return the accumulated value.\nBelow is the implementation using a tail-recursive function.\nNext articles on this topic:\nTail Call Elimination \nQuickSort Tail Call Optimization (Reducing worst case space to Log n )\n",
            "code_snippets": {
              "cpp": "#include <iostream>using namespace std;// A tail recursive function to calculate factorialunsigned factTR(unsigned int n, unsigned int a){    if (n <= 1)        return a;    return factTR(n - 1, n * a);}// A wrapper over factTRunsigned int fact(unsigned int n) { return factTR(n, 1); }// Driver program to test above functionint main(){    cout << fact(5);    return 0;}",
              "c": "// An example of tail recursive functionvoid print(int n){    if (n < 0)        return;    printf(\"%d \", n);    // The last executed statement is recursive call    print(n - 1);}",
              "java": "// Java Code for Tail RecursionclassGFG {    // A tail recursive function    // to calculate factorial    static int factTR(int n, int a)    {        if (n <= 0)            return a;        return factTR(n - 1, n * a);    }    // A wrapper over factTR    static int fact(int n) { return factTR(n, 1); }    // Driver code    static public void main(String[] args)    {        System.out.println(fact(5));    }}// This code is contributed by Smitha.",
              "python3": "# A tail recursive function# to calculate factorialdeffact(n,a=1):if(n<=1):returnareturnfact(n-1,n*a)# Driver program to test# above functionprint(fact(5))# This code is contributed# by Smitha# improved by Ujwal, ashish2021",
              "csharp": "// C# Code for Tail Recursionusing System;class GFG {    // A tail recursive function    // to calculate factorial    static int factTR(int n, int a)    {        if (n <= 0)            return a;        return factTR(n - 1, n * a);    }    // A wrapper over factTR    static int fact(int n) { return factTR(n, 1); }    // Driver code    static public void Main()    {        Console.WriteLine(fact(5));    }}// This code is contributed by Ajit.",
              "javascript": "<script>// Javascript Code for Tail Recursion// A tail recursive function// to calculate factorialfunction factTR(n, a){    if (n <= 0)        return a;     return factTR(n - 1, n * a);} // A wrapper over factTRfunction fact(n){    return factTR(n, 1);}// Driver code document.write(fact(5));// This code is contributed by rameshtravel07    </script>",
              "php": "<?php// A tail recursive function// to calculate factorialfunctionfactTR($n,$a){if($n<=0)return$a;returnfactTR($n-1,$n*$a);}// A wrapper over factTRfunctionfact($n){returnfactTR($n,1);}// Driver program to test // above functionechofact(5);// This code is contributed// by Smitha?>"
            }
          }
        ]
      },
      {
        "subtopic_title": "Introduction to Recursion",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-recursion-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Comparison of Recursive and Iterative Approaches",
            "content": "What is the base condition in recursion? \nA recursive program stops at a base condition. There can be more than one base conditions in a recursion. In the above program, the base condition is when n = 1.\nHow a particular problem is solved using recursion? \nThe idea is to represent a problem in terms of one or more smaller problems, and add one or more base conditions that stop the recursion.\nExample 2 : Factorial of a Number\nThe factorial of a number n (where n >= 0) is the product of all positive integers from 1 to n. To compute the factorial recursively, we calculate the factorial of n by using the factorial of (n-1). The base case for the recursive function is when n = 0, in which case we return 1.\nIllustration of the above code:\nWhen does Stack Overflow error occur in recursion?\nIf the base case is not reached or not defined, then the stack overflow problem may arise. Let us take an example to understand this.\nint fact(int n)\n{\n    // wrong base case (it may cause stack overflow).\n    if (n == 100) \n        return 1;\n    else\n        return n*fact(n-1);\n}\nIn this example, if fact(10) is called, the function will recursively call fact(9), then fact(8), fact(7), and so on. However, the base case checks if n == 100. Since n will never reach 100 during these recursive calls, the base case is never triggered. As a result, the recursion continues indefinitely.\nThis continuous recursion consumes memory on the function call stack. If the system’s memory is exhausted due to these unending function calls, a stack overflow error occurs.\nTo prevent this, it’s essential to define a proper base case, such as if (n == 0) to ensure that the recursion terminates and the function doesn’t run out of memory.\nWhat is the difference between direct and indirect recursion?\nA function is called direct recursive if it calls itself directly during its execution. In other words, the function makes a recursive call to itself within its own body.\nAn indirect recursive function is one that calls another function, and that other function, in turn, calls the original function either directly or through other functions. This creates a chain of recursive calls involving multiple functions, as opposed to direct recursion, where a function calls itself.\n// An example of direct recursion\nvoid directRecFun()\n{\n    // Some code….\n\n    directRecFun();\n\n    // Some code…\n}\n\n// An example of indirect recursion\nvoid indirectRecFun1()\n{\n    // Some code…\n\n    indirectRecFun2();\n\n    // Some code…\n}\nvoid indirectRecFun2()\n{\n    // Some code…\n\n    indirectRecFun1();\n\n    // Some code…\n}\nWhat is the difference between tail and non-tail recursion?\nA recursive function is tail recursive when a recursive call is the last thing executed by the function.\nPlease refer tail recursion for details.\nHow memory is allocated to different function calls in recursion?\nRecursion uses more memory to store data of every recursive call in an internal function call stack.\nWhenever we call a function, its record is added to the stack and remains there until the call is finished.\nThe internal systems use a stack because function calling follows LIFO structure, the last called function finishes first.\nWhen any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for a called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues.\nLet us take the example of how recursion works by taking a simple function.\nInitial Call: When printFun(3) is called from main(), memory is allocated for printFun(3). The local variable test is initialized to 3, and statements 1 to 4 are pushed onto the stack.\nFirst Recursive Call:\nprintFun(3) calls printFun(2).\nMemory for printFun(2) is allocated, the local variable test is initialized to 2, and statements 1 to 4 are pushed onto the stack.\nSecond Recursive Call:\nprintFun(2) calls printFun(1).\nMemory for printFun(1) is allocated, the local variable test is initialized to 1, and statements 1 to 4 are pushed onto the stack.\nThird Recursive Call:\nprintFun(1) calls printFun(0).\nMemory for printFun(0) is allocated, the local variable test is initialized to 0, and statements 1 to 4 are pushed onto the stack.\nBase Case: When printFun(0) is called, it hits the base case (if statement) and returns control to printFun(1).\nReturning from Recursion:\nAfter returning from printFun(0), the remaining statements of printFun(1) are executed and it returns control to printFun(2).\nSimilarly, after returning from printFun(2), control returns to printFun(3).\nOutput: As a result, the output will print the values in the following order:\nFrom 3 down to 1 (as the recursive calls are made).\nThen from 1 back to 3 (as the recursive calls unwind).\nThe memory stack grows with each function call and shrinks as the recursion unwinds, following the LIFO structure.\nRecursion VS Iteration\nWhat are the advantages of recursive programming over iterative programming?\nRecursion provides a clean and simple way to write code.\nSome problems are inherently recursive like tree traversals, Tower of Hanoi, etc. For such problems, it is preferred to write recursive code. We can write such codes also iteratively with the help of a stack data structure. For example refer Inorder Tree Traversal without Recursion, Iterative Tower of Hanoi.\nWhat are the disadvantages of recursive programming over iterative programming?\nNote every recursive program can be written iteratively and vice versa is also true.\nRecursive programs typically have more space requirements and also more time to maintain the recursion call stack.\nRecursion can make the code more difficult to understand and debug, since it requires thinking about multiple levels of function calls..\nExample 3 : Fibonacci with Recursion\nWrite a program and recurrence relation to find the Fibonacci series of n where n >= 0.\nMathematical Equation:\nn if n == 0, n == 1;      \nfib(n) = fib(n-1) + fib(n-2) otherwise;\nRecurrence Relation:\nT(n) = T(n-1) + T(n-2) + O(1)\nRecursion Tree for the above Code:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Common Applications of Recursion",
            "content": "Tree and Graph Traversal: Used for systematically exploring nodes/vertices in data structures like trees and graphs.\nSorting Algorithms: Algorithms like quicksort and merge sort divide data into subarrays, sort them recursively, and merge them.\nDivide-and-Conquer Algorithms: Algorithms like binary search break problems into smaller subproblems using recursion.\nFractal Generation: Recursion helps generate fractal patterns, such as the Mandelbrot set, by repeatedly applying a recursive formula.\nBacktracking Algorithms: Used for problems requiring a sequence of decisions, where recursion explores all possible paths and backtracks when needed.\nMemoization: Involves caching results of recursive function calls to avoid recomputing expensive subproblems.\nThese are just a few examples of the many applications of recursion in computer science and programming. Recursion is a versatile and powerful tool that can be used to solve many different types of problems.\nSummary of Recursion:\nThere are two types of cases in recursion i.e. recursive case and a base case.\nThe base case is used to terminate the recursive function when the case turns out to be true.\nEach recursive call makes a new copy of that method in the stack memory.\nInfinite recursion may lead to running out of stack memory.\nExamples of Recursive algorithms: Merge Sort, Quick Sort, Tower of Hanoi, Fibonacci Series, Factorial Problem, etc.\nOutput based practice problems for beginners: \nPractice Questions for Recursion | Set 1 \nPractice Questions for Recursion | Set 2 \nPractice Questions for Recursion | Set 3 \nPractice Questions for Recursion | Set 4 \nPractice Questions for Recursion | Set 5 \nPractice Questions for Recursion | Set 6 \nPractice Questions for Recursion | Set 7\nQuiz on Recursion \nCoding Practice on Recursion: \nAll Articles on Recursion \nRecursive Practice Problems with Solutions\n",
            "code_snippets": {
              "cpp": "// C++ code to implement Fibonacci series#include <bits/stdc++.h>using namespace std;// Function for fibonacciint fib(int n){    // Stop condition    if (n == 0)        return 0;    // Stop condition    if (n == 1 || n == 2)        return 1;    // Recursion function    else        return (fib(n - 1) + fib(n - 2));}// Driver Codeint main(){    // Initialize variable n.    int n = 5;    cout<<\"Fibonacci series of 5 numbers is: \";    // for loop to print the fibonacci series.    for (int i = 0; i < n; i++)     {        cout<<fib(i)<<\" \";    }    return 0;}",
              "c": "// C code to implement Fibonacci series#include <stdio.h>// Function for fibonacciint fib(int n){    // Stop condition    if (n == 0)        return 0;    // Stop condition    if (n == 1 || n == 2)        return 1;    // Recursion function    else        return (fib(n - 1) + fib(n - 2));}// Driver Codeint main(){    // Initialize variable n.    int n = 5;    printf(\"Fibonacci series \"           \"of %d numbers is: \",           n);    // for loop to print the fibonacci series.    for (int i = 0; i < n; i++) {        printf(\"%d \", fib(i));    }    return 0;}",
              "java": "// Java code to implement Fibonacci seriesimport java.util.*;classGFG{// Function for fibonaccistatic int fib(int n){    // Stop condition    if (n == 0)        return 0;    // Stop condition    if (n == 1 || n == 2)        return 1;    // Recursion function    else        return (fib(n - 1) + fib(n - 2));}// Driver Codepublic static void main(String []args){      // Initialize variable n.    int n = 5;    System.out.print(\"Fibonacci series of 5 numbers is: \");    // for loop to print the fibonacci series.    for (int i = 0; i < n; i++)     {        System.out.print(fib(i)+\" \");    }}}// This code is contributed by rutvik_56.",
              "python3": "# Python code to implement Fibonacci series# Function for fibonaccideffib(n):# Stop conditionif(n==0):return0# Stop conditionif(n==1orn==2):return1# Recursion functionelse:return(fib(n-1)+fib(n-2))# Driver Code# Initialize variable n.n=5;print(\"Fibonacci series of 5 numbers is :\",end=\" \")# for loop to print the fibonacci series.foriinrange(0,n):print(fib(i),end=\" \")",
              "csharp": "using System;public class GFG{  // Function for fibonacci  static int fib(int n)  {    // Stop condition    if (n == 0)      return 0;    // Stop condition    if (n == 1 || n == 2)      return 1;    // Recursion function    else      return (fib(n - 1) + fib(n - 2));  }  // Driver Code  static public void Main ()  {    // Initialize variable n.    int n = 5;    Console.Write(\"Fibonacci series of 5 numbers is: \");    // for loop to print the fibonacci series.    for (int i = 0; i < n; i++)     {      Console.Write(fib(i) + \" \");    }  }}// This code is contributed by avanitrachhadiya2155",
              "javascript": "// Function for fibonaccifunction fib(n) {    // Stop condition    if (n === 0) return 0;    // Stop condition    if (n === 1 || n === 2) return 1;    // Recursion function    return fib(n - 1) + fib(n - 2);}// Driver Codelet n = 5;console.log(\"Fibonacci series of 5 numbers is:\");// for loop to print the fibonacci series.for (let i = 0; i < n; i++) {    console.log(fib(i) + \" \");}",
              "php": "<?php// PHP program to demonstrate // working of recursion// function to demonstrate // working of recursionfunctionprintFun($test){if($test<1)return;else{echo(\"$test \");// statement 2printFun($test-1);echo(\"$test \");return;}}// Driver Code$test=3;printFun($test);// This code is contributed by// Smitha Dinesh Semwal.?>"
            }
          }
        ]
      },
      {
        "subtopic_title": "Why is Tail Recursion optimization faster than normal Recursion?",
        "subtopic_url": "https://www.geeksforgeeks.org/why-is-tail-recursion-optimization-faster-than-normal-recursion/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "What is tail recursion?",
            "content": "Tail recursion is defined as a recursive function in which the recursive call is the last statement that is executed by the function. So basically nothing is left to execute after the recursion call.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is non-tail recursion?",
            "content": "Non-tail or head recursion is defined as a recursive function in which the recursive call is the first statement that is executed by the function. It means there is no statement or operation before the recursive calls.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why is tail recursion optimization faster than normal recursion?",
            "content": "In non-tail recursive functions, after one recursive call is over, there are more statements to compute, and hence all the functions do not unfold as soon as the base case is hit.\nEvery time when a recursive call is done (or any function call), a stack frame is added to the call stack. This keeps track of where you were at the time the function call was made so we can continue from where we left off. If this is done enough times, say through a recursive function to compute the 1 billionth Fibonacci number, you can get a stack overflow, which will typically terminate the process.\nTail recursion works off the realization that some recursive calls don't need to \"continue from where they left off\" once the recursive call returns. Specifically, when the recursive call is the last statement that would be executed in the current context. Tail recursion is an optimization that doesn't bother to push a stack frame onto the call stack in these cases, which allows your recursive calls to go very deep in the call stack.\nIf the last action of a method is a call to another method, instead of creating a new stack frame for the context of the new method (arguments, local variables, etc.), we can replace the current one. One of the drawbacks of normal recursive methods is that they heavily use the call stack. Tail-call optimization eliminates this problem and guarantees that the performance of a recursive algorithm is exactly as good as its iterative counterpart (yet potentially it is much more readable).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Example of tail recursive function:",
            "content": "Time Complexity: O(N)\nAuxiliary Space: O(N)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Example of non-tail recursive function:",
            "content": "Time Complexity: O(N)\nAuxiliary Space: O(N)\nRelated Articles:\nWhat is Tail Recursion?\nTail Call Elimination\n",
            "code_snippets": {
              "cpp": "#include <iostream>using namespace std;// Non-tail recursionvoid fun(int n){  if (n == 0)    return;  fun(n - 1);  cout<<n<<\" \";}int main() {    fun(5);    return 0;}// This code is contributed by akashish__",
              "java": "// Java code to implement the approachimport java.util.*;classGFG {// Non-tail recursionstatic void fun(int n){    if(n == 0)        return;        fun(n-1);        System.out.print(n + \" \");}// Driver Codepublic static void main (String[] args) {    fun(5);}}// This code is contributed by Pushpesh Raj.",
              "python3": "# Non-tail recursiondeffun(n):if(n==0):returnfun(n-1)print(n,end=\" \")# Driver code    if__name__==\"__main__\":fun(5)",
              "csharp": "// C# code to implement the approachusing System;public class GFG {  // Non-tail recursion  static void fun(int n)  {    if (n == 0)      return;    fun(n - 1);    Console.Write(n + \" \");  }  static public void Main()  {    // Code    fun(5);  }}// This code is contributed by lokesh.",
              "javascript": "function fun(n) {  if (n === 0) return;  fun(n - 1);  console.log(n);}fun(5);// This code is contributed by akashish__"
            }
          }
        ]
      },
      {
        "subtopic_title": "Finite and Infinite Recursion with examples",
        "subtopic_url": "https://www.geeksforgeeks.org/finite-and-infinite-recursion-with-examples/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Difference between Recursion and Iteration",
        "subtopic_url": "https://www.geeksforgeeks.org/difference-between-recursion-and-iteration/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "1. Time Complexity",
            "content": "The time complexity of the method may vary depending on whether the algorithm is implemented using recursion or iteration.\nRecursion: The time complexity of recursion can be found by finding the value of the nth recursive call in terms of the previous calls. Thus, finding the destination case in terms of the base case, and solving in terms of the base case gives us an idea of the time complexity of recursive equations. Please see Solving Recurrences for more details.\n Iteration: The time complexity of iteration can be found by finding the number of cycles being repeated inside the loop.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Usage",
            "content": "Usage of either of these techniques is a trade-off between time complexity and size of code. If time complexity is the point of focus, and the number of recursive calls would be large, it is better to use iteration. However, if time complexity is not an issue and shortness of code is, recursion would be the way to go.\nRecursion: Recursion involves calling the same function again, and hence, has a very small length of code. However, as we saw in the analysis, the time complexity of recursion can get to be exponential when there are a considerable number of recursive calls. Hence, usage of recursion is advantageous in shorter code, but higher time complexity.\n Iteration: Iteration is the repetition of a block of code. This involves a larger size of code, but the time complexity is generally lesser than it is for recursion.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Overhead",
            "content": "Recursion has a large amount of Overhead as compared to Iteration.\nRecursion: Recursion has the overhead of repeated function calls, that is due to the repetitive calling of the same function, the time complexity of the code increases manyfold.\n Iteration: Iteration does not involve any such overhead.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Infinite Repetition",
            "content": "Infinite Repetition in recursion can lead to a CPU crash but in iteration, it will stop when memory is exhausted.\nRecursion: In Recursion, Infinite recursive calls may occur due to some mistake in specifying the base condition, which on never becoming false, keeps calling the function, which may lead to a system CPU crash.\n Iteration: Infinite iteration due to a mistake in iterator assignment or increment, or in the terminating condition, will lead to infinite loops, which may or may not lead to system errors, but will surely stop program execution any further.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Difference between Iteration and Recursion",
            "content": "The following table lists the major differences between iteration and recursion:\n",
            "code_snippets": {
              "c": "// C program to find factorial of given number#include <stdio.h>// ----- Recursion -----// method to find factorial of given numberint factorialUsingRecursion(int n){    if (n == 0)        return 1;    // recursion call    return n * factorialUsingRecursion(n - 1);}// ----- Iteration -----// Method to find the factorial of a given numberint factorialUsingIteration(int n){    int res = 1, i;    // using iteration    for (i = 2; i <= n; i++)        res *= i;    return res;}// Driver methodint main(){    int num = 5;    printf(\"Factorial of %d using Recursion is: %d\\n\", num,           factorialUsingRecursion(5));    printf(\"Factorial of %d using Iteration is: %d\", num,           factorialUsingIteration(5));    return 0;}// This code is contributed by mits",
              "CPP": "// C++ program to find factorial of given number#include<bits/stdc++.h>using namespace std;// ----- Recursion -----// method to find factorial of given numberint factorialUsingRecursion(int n){    if (n == 0)        return 1;    // recursion call    return n * factorialUsingRecursion(n - 1);}// ----- Iteration -----// Method to find the factorial of a given numberint factorialUsingIteration(int n){    int res = 1, i;    // using iteration    for (i = 2; i <= n; i++)        res *= i;    return res;}// Driver methodint main(){    int num = 5;    cout << \"Factorial of \" << num <<             \" using Recursion is: \" <<            factorialUsingRecursion(5) << endl;    cout << \"Factorial of \" << num <<            \" using Iteration is: \" <<             factorialUsingIteration(5);    return 0;}// This code is contributed by mits",
              "Java": "// Java program to find factorial of given numberclassGFG {    // ----- Recursion -----    // method to find factorial of given number    static int factorialUsingRecursion(int n)    {        if (n == 0)            return 1;        // recursion call        return n * factorialUsingRecursion(n - 1);    }    // ----- Iteration -----    // Method to find the factorial of a given number    static int factorialUsingIteration(int n)    {        int res = 1, i;        // using iteration        for (i = 2; i <= n; i++)            res *= i;        return res;    }    // Driver method    public static void main(String[] args)    {        int num = 5;        System.out.println(\"Factorial of \" + num                           + \" using Recursion is: \"                           + factorialUsingRecursion(5));        System.out.println(\"Factorial of \" + num                           + \" using Iteration is: \"                           + factorialUsingIteration(5));    }}",
              "Python3": "# Python3 program to find factorial of given number# ----- Recursion -----# method to find factorial of given numberdeffactorialUsingRecursion(n):if(n==0):return1;# recursion callreturnn*factorialUsingRecursion(n-1);# ----- Iteration -----# Method to find the factorial of a given numberdeffactorialUsingIteration(n):res=1;# using iterationforiinrange(2,n+1):res*=i;returnres;# Driver methodnum=5;print(\"Factorial of\",num,\"using Recursion is:\",factorialUsingRecursion(5));print(\"Factorial of\",num,\"using Iteration is:\",factorialUsingIteration(5));# This code is contributed by mits",
              "CSHARP": "// C# program to find factorial of // given numberusing System;class GFG{    // ----- Recursion -----    // method to find factorial of     // given number    static int factorialUsingRecursion(int n)    {        if (n == 0)            return 1;        // recursion call        return n * factorialUsingRecursion(n - 1);    }    // ----- Iteration -----    // Method to find the factorial of    // a given number    static int factorialUsingIteration(int n)    {        int res = 1, i;        // using iteration        for (i = 2; i <= n; i++)            res *= i;        return res;    }    // Driver Code    public static void Main(String[] args)    {        int num = 5;        Console.WriteLine(\"Factorial of \" + num +                           \" using Recursion is: \" +                           factorialUsingRecursion(5));        Console.WriteLine(\"Factorial of \" + num +                           \" using Iteration is: \" +                           factorialUsingIteration(5));    }}// This code has been contributed by Rajput-Ji",
              "php": "<?php// PHP program to find factorial of given number// ----- Recursion -----// method to find factorial of given numberfunctionfactorialUsingRecursion($n){if($n==0)return1;// recursion callreturn$n*factorialUsingRecursion($n-1);}// ----- Iteration -----// Method to find the factorial of a given numberfunctionfactorialUsingIteration($n){$res=1;// using iterationfor($i=2;$i<=$n;$i++)$res*=$i;return$res;}// Driver method$num=5;print(\"Factorial of \".$num.\" using Recursion is: \".factorialUsingRecursion(5).\"\\n\");print(\"Factorial of \".$num.\" using Iteration is: \".factorialUsingIteration(5).\"\\n\");// This code is contributed by mits?>",
              "javascript": "<script>// JavaScript program to find factorial of given number// ----- Recursion -----// method to find factorial of given numberfunction factorialUsingRecursion(n)    {        if (n == 0)            return 1;        // recursion call        return n * factorialUsingRecursion(n - 1);    }    // ----- Iteration -----    // Method to find the factorial of a given number    function factorialUsingIteration(n)    {        var res = 1, i;        // using iteration        for (i = 2; i <= n; i++)            res *= i;        return res;    }    // Driver method        var num = 5;        document.write(\"Factorial of \" + num                           + \" using Recursion is: \"                           + factorialUsingRecursion(5)+\"<br>\");        document.write(\"Factorial of \" + num                           + \" using Iteration is: \"                           + factorialUsingIteration(5));    // This code is contributed by shivanisinghss2110</script>"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "12. Matrix/Grid",
    "main_article_link": "https://www.geeksforgeeks.org/matrix/",
    "subtopics": [
      {
        "subtopic_title": "Matrix or Grid or 2D Array - Complete Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-matrix-or-grid-data-structure-and-algorithms-tutorial/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Representation of Matrix Data Structure:",
            "content": "As you can see from the below image, the elements are organized in rows and columns. As shown in the image, the cell a[0][0] is the first element of the first row and first column.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Declaration of Matrix",
            "content": "Declaration of a Matrix or two-dimensional array is very much similar to that of a one-dimensional array, given as follows.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Initializing Matrix",
            "content": "In initialization, we assign some initial value to all the cells of the matrix. Below is the implementation to initialize a matrix in different languages:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operations on Matrix",
            "content": "We can perform a variety of operations on the Matrix Data Structure. Some of the most common operations are:\nAccess elements of Matrix\nTraversal of a Matrix\nSearching in a Matrix\nSorting a Matrix\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Access elements of Matrix Data Structure:",
            "content": "Like one-dimensional arrays, matrices can be accessed randomly by using their indices to access the individual elements. A cell has two indices, one for its row number, and the other for its column number. We can use arr[i][j] to access the element which is at the ith row and jth column of the matrix.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Traversal of a Matrix Data Structure:",
            "content": "We can traverse all the elements of a matrix or two-dimensional array by using two for-loops.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Searching in a Matrix Data Structure:",
            "content": "We can search an element in a matrix by traversing all the elements of the matrix.\nBelow is the implementation to search an element in a matrix:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Sorting Matrix Data Structure:",
            "content": "We can sort a matrix in two-ways:\nSort the matrix row-wise\nSort the matrix column-wise\nRelated Article:\nLearn Data Structures and Algorithms | DSA Tutorial\nWhy Data Structures and Algorithms Are Important to Learn?\nThe Ultimate Beginner’s Guide For DSA\nIntroduction to Data Structures\nWhat is Algorithm | Introduction to Algorithms\nProblems on Matrix Data Structure\n",
            "code_snippets": {
              "cpp": "#include <bits/stdc++.h>using namespace std;bool searchInMatrix(vector<vector<int> >& arr, int x){    int m = arr.size(), n = arr[0].size();    for (int i = 0; i < m; i++) {        for (int j = 0; j < n; j++) {            if (arr[i][j] == x)                return true;        }    }    return false;}// Driver program to test aboveint main(){    int x = 8;    vector<vector<int> > arr        = { { 0, 6, 8, 9, 11 },            { 20, 22, 28, 29, 31 },            { 36, 38, 50, 61, 63 },            { 64, 66, 100, 122, 128 } };    if (searchInMatrix(arr, x))        cout << \"YES\" << endl;    else        cout << \"NO\" << endl;    return 0;}",
              "c": "#include <stdio.h>int main(){    int arr[3][4] = { { 1, 2, 3, 4 },                      { 5, 6, 7, 8 },                      { 9, 10, 11, 12 } };    // Traversing over all the rows    for (int i = 0; i < 3; i++) {        // Traversing over all the columns of each row        for (int j = 0; j < 4; j++) {            printf(\"%d \", arr[i][j]);        }        printf(\"\\n\");    }    return 0;}",
              "java": "// Java code for the above approachimport java.io.*;classGFG {  static boolean searchInMatrix(int[][] arr, int x)  {    int m = arr.length, n = arr[0].length;    for (int i = 0; i < m; i++) {      for (int j = 0; j < n; j++) {        if (arr[i][j] == x)          return true;      }    }    return false;  }  public static void main(String[] args)  {    int x = 8;    int[][] arr = { { 0, 6, 8, 9, 11 },                   { 20, 22, 28, 29, 31 },                   { 36, 38, 50, 61, 63 },                   { 64, 66, 100, 122, 128 } };    if (searchInMatrix(arr, x)) {      System.out.println(\"YES\");    }    else {      System.out.println(\"NO\");    }  }}// This code is contributed by lokeshmvs21.",
              "python3": "# Function to search for an element in a 2-D listdefsearch_in_matrix(arr,x):rows,cols=len(arr),len(arr[0])# Traverse each row and columnforiinrange(rows):forjinrange(cols):ifarr[i][j]==x:returnTruereturnFalse# Driver code to test the functionx=8arr=[[0,6,8,9,11],[20,22,28,29,31],[36,38,50,61,63],[64,66,100,122,128]]ifsearch_in_matrix(arr,x):print(\"YES\")else:print(\"NO\")",
              "csharp": "// C# code for the above approachusing System;public class GFG {    static bool searchInMatrix(int[,] arr, int x) {        int m = arr.GetLength(0), n = arr.GetLength(1);        for (int i = 0; i < m; i++) {            for (int j = 0; j < n; j++) {                if (arr[i, j] == x)                    return true;            }        }        return false;    }    public static void Main(string[] args) {        int x = 8;        int[,] arr = { { 0, 6, 8, 9, 11 },            { 20, 22, 28, 29, 31 },            { 36, 38, 50, 61, 63 },            { 64, 66, 100, 122, 128 }        };        if (searchInMatrix(arr, x)) {            Console.WriteLine(\"YES\");        } else {            Console.WriteLine(\"NO\");        }    }}",
              "javascript": "// JavaScript code for the above approachfunction searchInMatrix(arr, x){    let m = arr.length, n = arr[0].length;    for (let i = 0; i < m; i++) {        for (let j = 0; j < n; j++) {            if (arr[i][j] == x)                return true;        }    }    return false;}// Driver program to test abovelet x = 8;let arr = [    [ 0, 6, 8, 9, 11 ],    [ 20, 22, 28, 29, 31 ],    [ 36, 38, 50, 61, 63 ],    [ 64, 66, 100, 122, 128 ]];if (searchInMatrix(arr, x))    console.log(\"YES\");else    console.log(\"NO\");"
            }
          }
        ]
      },
      {
        "subtopic_title": "Row-wise vs column-wise traversal of matrix",
        "subtopic_url": "https://www.geeksforgeeks.org/row-wise-vs-column-wise-traversal-matrix/",
        "sub_subtopics": []
      }
    ]
  },
  {
    "topic_name": "13. Linked List",
    "main_article_link": "https://www.geeksforgeeks.org/linked-list-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Introduction to Circular Linked List",
        "subtopic_url": "https://www.geeksforgeeks.org/circular-linked-list/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "What is a Circular Linked List?",
            "content": "A circular linked list is a special type of linked list where all the nodes are connected to form a circle. Unlike a regular linked list, which ends with a node pointing to NULL, the last node in a circular linked list points back to the first node. This means that you can keep traversing the list without ever reaching a NULL value.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Circular Linked Lists",
            "content": "We can create a circular linked list from both singly linked lists and doubly linked lists. So, circular linked lists are basically of two types:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Circular Singly Linked List",
            "content": "In Circular Singly Linked List, each node has just one pointer called the “next” pointer. The next pointer of the last node points back to the first node and this results in forming a circle. In this type of Linked list, we can only move through the list in one direction.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Circular Doubly Linked List:",
            "content": "In circular doubly linked list, each node has two pointers prev and next, similar to doubly linked list. The prev pointer points to the previous node and the next points to the next node. Here, in addition to the last node storing the address of the first node, the first node will also store the address of the last node.\nNote: In this article, we will use the singly linked list to explain the working of circular linked lists.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of a Circular Singly Linked List",
            "content": "Let’s take a look on the structure of a circular linked list.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Create/Declare a Node of Circular Linked List",
            "content": "Syntax to Declare a Circular Linked List in Different Languages:\nIn the code above, each node has data and a pointer to the next node. When we create multiple nodes for a circular linked list, we only need to connect the last node back to the first one.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Example of Creating a Circular Linked List",
            "content": "Here’s an example of creating a circular linked list with three nodes (2, 3, 4):\nIn the above code, we have created three nodes first, second, and last having values 2, 3, and 4 respectively.\nAfter creating three nodes, we have connected these node in a series.\nConnect the first node “first” to “second” node by storing the address of “second” node into first’s next\nConnect the second node “second” to “third” node by storing the address of “third” node into second’s next\nAfter connecting all the nodes, we reach the key characteristic of a circular linked list: linking the last node back to the first node. Therefore, we store the address of the “first” node in the “last” node.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why have we taken a pointer that points to the last node instead of the first node?",
            "content": "For the insertion of a node at the beginning, we need to traverse the whole list. Also, for insertion at the end, the whole list has to be traversed. If instead of the start pointer, we take a pointer to the last node, then in both cases there won’t be any need to traverse the whole list. So insertion at the beginning or at the end takes constant time, irrespective of the length of the list.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operations on the Circular Linked list",
            "content": "We can do some operations on the circular linked list similar to the singly and doubly linked list which are:\n1. Insertion\nInsertion at the empty list\nInsertion at the beginning\nInsertion at the end\nInsertion at the given position\n2. Deletion\nDelete the first node\nDelete the last node\nDelete the node from any position\n3. Searching\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Insertion in the circular linked list",
            "content": "Insertion is a fundamental operation in linked lists that involves adding a new node to the list. The only extra step is connecting the last node to the first one. In the circular linked list mentioned below, we can insert nodes in four ways:\nTo insert a node in empty circular linked list, creates a new node with the given data, sets its next pointer to point to itself, and updates the last pointer to reference this new node.\nTo read more about insertion in an empty list Refer, Insertion in an empty List in the circular linked list\nTo insert a new node at the beginning of a circular linked list, we create a new node and check if the list is empty. If empty, the new node points to itself. If not, we make the new node’s next pointer point to the current head (last->next) and update the last node’s next to the new node, preserving the circular structure.\nTo read more about Insertion at the beginning Refer, Insertion at the beginning in circular linked list\nTo insert a node at the end of a circular linked list, we create the new node and, if the list is empty, make it point to itself. Otherwise, we update the tail’s next pointer to the new node and then set the tail to the new node, preserving the circular linkage.\nTo read more about Insertion at the end Refer, Insertion at the end in circular linked list\nTo insert a node at a specific position in a circular linked list, we handle edge cases for an empty list and invalid positions. For valid positions, we traverse the list and adjust the pointers to insert the new node, updating the tail if it’s inserted at the end.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Deletion from a Circular Linked List",
            "content": "Deletion involves removing a node from the linked list. The main difference is that we need to ensure the list remains circular after the deletion. We can delete a node in a circular linked list in three ways:\nTo delete the first node of a circular linked list, we check if the list is empty or has only one node. If so, we handle those cases by deleting the node and updating the last pointer. For multiple nodes, we update the last node’s next pointer to skip the head and free the head node, returning the updated last pointer.\nTo delete a specific node from a circular linked list, we handle empty list and single node cases. For other nodes, we use two pointers to find the node, update the previous node’s next pointer to skip the target, and delete it, updating the last pointer if needed.\nTo delete the last node in a circular linked list, we handle the empty and single node cases. For multiple nodes, we traverse to find the second last node, update its next pointer to the head, delete the last node, and return the updated last pointer.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Searching in Circular Linked list",
            "content": "Searching in a circular linked list is similar to searching in a regular linked list. We start at a given node and traverse the list until you either find the target value or return to the starting node. Since the list is circular, make sure to keep track of where you started to avoid an infinite loop.\nTo read more about searching Refer, Searching in Circular Linked list\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Circular Linked Lists",
            "content": "In circular linked list, the last node points to the first node. There are no null references, making traversal easier and reducing the chances of encountering null pointer exceptions.\nWe can traverse the list from any node and return to it without needing to restart from the head, which is useful in applications requiring a circular iteration.\nCircular linked lists can easily implement circular queues, where the last element connects back to the first, allowing for efficient resource management.\nIn a circular linked list, each node has a reference to the next node in the sequence. Although it doesn’t have a direct reference to the previous node like a doubly linked list, we can still find the previous node by traversing the list.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Circular Linked Lists",
            "content": "Circular linked lists are more complex to implement than singly linked lists.\nTraversing a circular linked list without a clear stopping condition can lead to infinite loops if not handled carefully.\nDebugging can be more challenging due to the circular nature, as traditional methods of traversing linked lists may not apply.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Circular Linked Lists",
            "content": "It is used for time-sharing among different users, typically through a Round-Robin scheduling mechanism.\nIn multiplayer games, a circular linked list can be used to switch between players. After the last player’s turn, the list cycles back to the first player.\nCircular linked lists are often used in buffering applications, such as streaming data, where data is continuously produced and consumed.\nIn media players, circular linked lists can manage playlists, this allowing users to loop through songs continuously.\nBrowsers use circular linked lists to manage the cache. This allows you to navigate back through your browsing history efficiently by pressing the BACK button.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Related Article:",
            "content": "Circular Linked List meaning in DSA\nSingly Linked List Tutorial\nDoubly Linked List Tutorial\n",
            "code_snippets": {
              "cpp": "#include <iostream>using namespace std;struct Node {    int data;    Node* next;    Node(int value) {        data = value;        next = nullptr;    }};// Function to delete the last node in the circular linked listNode* deleteLastNode(Node* last) {    if (last == nullptr) {        // If the list is empty        cout << \"List is empty, nothing to delete.\" << endl;        return nullptr;    }    Node* head = last->next;    // If there is only one node in the list    if (head == last) {        delete last;        last = nullptr;        return last;    }    // Traverse the list to find the second last node    Node* curr = head;    while (curr->next != last) {        curr = curr->next;    }    // Update the second last node's next pointer    // to point to head    curr->next = head;    delete last;    last = curr;    return last;}void printList(Node* last) {   if(last == NULL) return;    Node *head = last->next;    while (true){        cout << head->data << \" \";        head = head->next;        if (head == last->next) break;    }    cout << endl;}int main() {    // Create circular linked list: 2, 3, 4    Node* first = new Node(2);    first->next = new Node(3);    first->next->next = new Node(4);    Node* last = first->next->next;    last->next = first;    cout << \"Original list: \";    printList(last);    // Delete the last node    last = deleteLastNode(last);    cout << \"List after deleting last node: \";    printList(last);    return 0;}",
              "c": "#include <stdio.h>#include <stdlib.h>// Define the structure for a node in the circular linked liststruct Node {    int data;    struct Node* next;};// Function to delete the last node in the circular linked liststruct Node* deleteLastNode(struct Node* last) {    if (last == NULL) {        // If the list is empty        printf(\"List is empty, nothing to delete.\\n\");        return NULL;    }    struct Node* head = last->next;    // If there is only one node in the list    if (head == last) {        free(last);        last = NULL;        return last;    }    // Traverse the list to find the second last node    struct Node* curr = head;    while (curr->next != last) {        curr = curr->next;    }    // Update the second last node's next pointer to point to head    curr->next = head;    free(last);    last = curr;    return last;}void printList(struct Node* last) {    if (last == NULL) return;    struct Node* head = last->next;    while (1) {        printf(\"%d \", head->data);        head = head->next;        if (head == last->next) break;    }    printf(\"\\n\");}struct Node* createNode(int value) {    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));    newNode->data = value;    newNode->next = NULL;    return newNode;}int main() {    // Create circular linked list: 2, 3, 4    struct Node* first = createNode(2);    first->next = createNode(3);    first->next->next = createNode(4);    struct Node* last = first->next->next;    last->next = first;    printf(\"Original list: \");    printList(last);    // Delete the last node    last = deleteLastNode(last);    printf(\"List after deleting last node: \");    printList(last);    return 0;}",
              "java": "classNode {    int data;    Node next;    Node(int value){        data = value;        next = null;    }}public classGFG {    public static Node deleteLastNode(Node last){        if (last == null) {            // If the list is empty            System.out.println(                \"List is empty, nothing to delete.\");            return null;        }        Node head = last.next;        // If there is only one node in the list        if (head == last) {            last = null;            return last;        }        // Traverse the list to find the second last node        Node curr = head;        while (curr.next != last) {            curr = curr.next;        }        // Update the second last node's next pointer to        // point to head        curr.next = head;        last = curr;        return last;    }    public static void printList(Node last){        if (last == null)            return;        Node head = last.next;        while (true) {            System.out.print(head.data + \" \");            head = head.next;            if (head == last.next)                break;        }        System.out.println();    }    public static void main(String[] args){        // Create circular linked list: 2, 3, 4        Node first = new Node(2);        first.next = new Node(3);        first.next.next = new Node(4);        Node last = first.next.next;        last.next = first;        System.out.print(\"Original list: \");        printList(last);        // Delete the last node        last = deleteLastNode(last);        System.out.print(\"List after deleting last node: \");        printList(last);    }}",
              "python3": "classNode:def__init__(self,data):self.data=dataself.next=NonedefdeleteLastNode(last):iflastisNone:# If the list is emptyprint(\"List is empty, nothing to delete.\")returnNonehead=last.next# If there is only one node in the listifhead==last:last=Nonereturnlast# Traverse the list to find the second last nodecurr=headwhilecurr.next!=last:curr=curr.next# Update the second last node's next pointer to point to headcurr.next=headlast=currreturnlastdefprintList(last):iflastisNone:returnhead=last.nextwhileTrue:print(head.data,end=\" \")head=head.nextifhead==last.next:breakprint()# Create circular linked list: 2, 3, 4first=Node(2)first.next=Node(3)first.next.next=Node(4)last=first.next.nextlast.next=firstprint(\"Original list: \",end=\"\")printList(last)# Delete the last nodelast=deleteLastNode(last)print(\"List after deleting last node: \",end=\"\")printList(last)",
              "csharp": "using System;public class Node {    public int data;    public Node next;    public Node(int value)    {        data = value;        next = null;    }}public class GFG {    // Function to delete the last node in the circular    // linked list    public static Node deleteLastNode(Node last)    {        if (last == null) {            // If the list is empty            Console.WriteLine(                \"List is empty, nothing to delete.\");            return null;        }        Node head = last.next;        // If there is only one node in the list        if (head == last) {            last = null;            return last;        }        // Traverse the list to find the second last node        Node curr = head;        while (curr.next != last) {            curr = curr.next;        }        // Update the second last node's next pointer        // to point to head        curr.next = head;        last = curr;        return last;    }    // Function to print the circular linked list    public static void printList(Node last)    {        if (last == null) {            Console.WriteLine(\"List is Empty\");            return;        }        Node head = last.next;        while (true) {            Console.Write(head.data + \" \");            head = head.next;            if (head == last.next)                break;        }        Console.WriteLine();    }    public static void Main(string[] args)    {        // Create circular linked list: 2, 3, 4        Node first = new Node(2);        first.next = new Node(3);        first.next.next = new Node(4);        Node last = first.next.next;        last.next = first;        Console.Write(\"Original list: \");        printList(last);        // Delete the last node        last = deleteLastNode(last);        Console.Write(\"List after deleting last node: \");        printList(last);    }}",
              "javascript": "class Node {    constructor(data) {        this.data = data;        this.next = null;    }}function deleteLastNode(last) {    if (last === null) {        // If the list is empty        console.log(\"List is empty, nothing to delete.\");        return null;    }    let head = last.next;    // If there is only one node in the list    if (head === last) {        last = null;        return last;    }    // Traverse the list to find the second last node    let curr = head;    while (curr.next !== last) {        curr = curr.next;    }    // Update the second last node's next pointer to point to head    curr.next = head;    last = curr;    return last;}function printList(last) {    if (last === null) return;    let head = last.next;    while (true) {        process.stdout.write(head.data + \" \");        head = head.next;        if (head === last.next) break;    }    console.log();}// Create circular linked list: 2, 3, 4let first = new Node(2);first.next = new Node(3);first.next.next = new Node(4);let last = first.next.next;last.next = first;console.log(\"Original list: \");printList(last);// Delete the last nodelast = deleteLastNode(last);console.log(\"List after deleting last node: \");printList(last);"
            }
          }
        ]
      },
      {
        "subtopic_title": "Doubly Linked List Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/doubly-linked-list/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Representation of Doubly Linked List in Data Structure",
            "content": "In a data structure, a doubly linked list is represented using nodes that have three fields:\nData\nA pointer to the next node (next)\nA pointer to the previous node (prev)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Node Definition",
            "content": "Here is how a node in a Doubly Linked List is typically represented:\nEach node in a Doubly Linked List contains the data it holds, a pointer to the next node in the list, and a pointer to the previous node in the list. By linking these nodes together through the next and prev pointers, we can traverse the list in both directions (forward and backward), which is a key feature of a Doubly Linked List.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Traversal in Doubly Linked List",
            "content": "Traversal in a Doubly Linked List involves visiting each node, processing its data, and moving to the next or previous node using the forward (next) and backward (prev) pointers.\nStep-by-Step Approach for Traversal:\nStart from the head of the list.\nTraverse forward:\nVisit the current node and process its data (e.g., print it).\nMove to the next node using current = current->next.\nRepeat the process until the end of the list (current == NULL).\nOptionally, traverse backward:\nStart from the tail (last node).\nVisit the current node and process its data.\nMove to the previous node using current = current->prev.\nRepeat the process until the beginning of the list (current == NULL).\nTraversal is useful for displaying or processing all nodes in a doubly linked list.\nTo read more about Traversal Operation Refer, Traversal in Doubly Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Finding Length of Doubly Linked List",
            "content": "A Doubly Linked List (DLL) is a type of linked list where each node has two pointers:\nOne pointing to the next node in the sequence.\nOne pointing to the previous node in the sequence.\nTo find the length of a doubly linked list, we need to traverse the list while counting the nodes.\nStep-by-Step Approach for finding length:\nInitialize a counter: Start with a counter variable (count = 0).\nSet a pointer to the head node: Use a pointer (current) and initialize it to the head of the linked list.\nTraverse the list:\nWhile the pointer (current) is not NULL, increment the count by 1.\nMove to the next node (current = current.next).\nStop at the end of the list: When the pointer reaches NULL, stop the loop.\nReturn the count: The final value of count gives the length of the doubly linked list.\nTo read more about Finding Length of DLL Refer, Program to find size of Doubly Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Insertion in a Doubly Linked List",
            "content": "Insertion in a Doubly Linked List (DLL) involves adding a new node at a specific position while maintaining the connections between nodes. Since each node contains a pointer to both the previous and next node, insertion requires adjusting these pointers carefully.\nThere are three primary types of insertion in a DLL:\n1. Insertion at the Beginning\nCreate a new node with the given data.\nSet the next pointer of the new node to the current head.\nIf the list is not empty, update the prev pointer of the current head to point to the new node.\nUpdate the head of the list to the new node.\nRead more about Insertion at the Beginning Refer, Insert a Node at Front/Beginning of Doubly Linked List\n2. Insertion at the End\nCreate a new node with the given data.\nIf the list is empty, set the new node as the head.\nTraverse the list until the last node is found.\nSet the next pointer of the last node to the new node.\nSet the prev pointer of the new node to the last node.\nRead more about Insertion at the End Refer, Insert a Node at the end of Doubly Linked List\n3. Insertion at a Specific Position\nCreate a new node with the given data.\nIf inserting at the beginning, follow the steps for insertion at the start.\nTraverse the list to find the node after which insertion is needed.\nSet the next pointer of the new node to the next node of the current position.\nSet the prev pointer of the new node to the current node.\nUpdate the prev pointer of the next node to point to the new node (if it exists).\nUpdate the next pointer of the previous node to point to the new node.\nRead more about Insertion at a specific position Refer, Insert a Node at a specific position in Doubly Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Deletion in a Doubly Linked List",
            "content": "Deletion in a Doubly Linked List (DLL) involves removing a node while maintaining the integrity of the list. Since each node contains pointers to both its previous and next nodes, deletion requires careful pointer adjustments to ensure no broken links occur.\nTypes of Deletion in a Doubly Linked List\n1. Deletion at the Beginning\nCheck if the list is empty; if it is, return as there is nothing to delete.\nStore the current head node in a temporary variable.\nMove the head pointer to the next node.\nIf the new head exists, update its prev pointer to NULL.\nDelete the old head node to free memory.\nRead more about Deletion at the Beginning Refer, Deletion at beginning (Removal of first node) in a Doubly Linked List\n2. Deletion at the End\nCheck if the list is empty; if it is, return.\nTraverse the list to find the last node.\nStore the last node in a temporary variable.\nUpdate the next pointer of the second-last node to NULL, making it the new tail.\nDelete the last node to free memory.\nRead more about Deletion at the End Refer, Deletion at end (Removal of last node) in a Doubly Linked List\n3. Deletion at a Specific Position\nCheck if the list is empty; if it is, return.\nTraverse the list to find the node to be deleted.\nStore the node to be deleted in a temporary variable.\nUpdate the next pointer of the previous node to point to the next node.\nUpdate the prev pointer of the next node to point to the previous node (if it exists).\nDelete the target node to free memory.\nRead more about Deletion at a specific position Refer, Delete a Doubly Linked List node at a given position\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Doubly Linked List",
            "content": "Efficient traversal in both directions: Doubly linked lists allow for efficient traversal of the list in both directions, making it suitable for applications where frequent insertions and deletions are required.\nEasy insertion and deletion of nodes: The presence of pointers to both the previous and next nodes makes it easy to insert or delete nodes from the list, without having to traverse the entire list.\nCan be used to implement a stack or queue: Doubly linked lists can be used to implement both stacks and queues, which are common data structures used in programming.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Doubly Linked List",
            "content": "More complex than singly linked lists: Doubly linked lists are more complex than singly linked lists, as they require additional pointers for each node.\nMore memory overhead: Doubly linked lists require more memory overhead than singly linked lists, as each node stores two pointers instead of one.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Doubly Linked List",
            "content": "Implementation of undo and redo functionality in text editors.\nCache implementation where quick insertion and deletion of elements are required.\nBrowser history management to navigate back and forth between visited pages.\nMusic player applications to manage playlists and navigate through songs efficiently.\nImplementing data structures like Deque (double-ended queue) for efficient insertion and deletion at both ends.\nPractice Questions on Doubly Linked List\nMCQs on Linked List\n",
            "code_snippets": {
              "cpp": "struct Node {    // To store the Value or data.    int data;    // Pointer to point the Previous Element    Node* prev;    // Pointer to point the Next Element    Node* next;      // Constructor    Node(int d) {       data = d;       prev = next = nullptr;          }};",
              "c": "struct Node {    // To store the Value or data.    int data;    // Pointer to point the Previous Element    Node* prev;    // Pointer to point the Next Element    Node* next;};// Function to create a new nodestruct Node *createNode(int new_data) {    struct Node *new_node = (struct Node *)    malloc(sizeof(struct Node));    new_node->data = new_data;    new_node->next = NULL;    new_node->prev = NULL;    return new_node;}",
              "java": "classNode {    // To store the Value or data.    int data;    // Reference to the Previous Node    Node prev;      // Reference to the next Node    Node next;      // Constructor    Node(int d) {       data = d;       prev = next = null;          }};",
              "python3": "classNode:def__init__(self,data):# To store the value or data.self.data=data# Reference to the previous nodeself.prev=None# Reference to the next nodeself.next=None",
              "csharp": "class Node{  \t// To store the value or data    public int Data;     \t// Pointer to the next node    public Node Next;     \t// Pointer to the previous node    public Node Prev;     // Constructor    public Node(int d)    {        Data = d;        Prev = Next = null;          }}",
              "javascript": "class Node {    constructor(data)    {        // To store the value or data.        this.data = data;        // Reference to the previous node        this.prev = null;        // Reference to the next node        this.next = null;    }}"
            }
          }
        ]
      },
      {
        "subtopic_title": "Singly Linked List Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/singly-linked-list-tutorial/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Understanding Node Structure",
            "content": "In a singly linked list, each node consists of two parts: data and a pointer to the next node. This structure allows nodes to be dynamically linked together, forming a chain-like sequence.\nIn this example, the Node class contains an integer data field (data) to store the information and a pointer to another Node (next) to establish the link to the next node in the list.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Traversal",
            "content": "Traversal in a linked list means visiting each node and performing operations like printing or processing data.\nStep-by-step approach:\nInitialize a pointer (current) to the head of the list.\nLoop through the list using a while loop until current becomes NULL.\nProcess each node (e.g., print its data).\nMove to the next node by updating current = current->next.\nTo read more about Traversal Operation in linked list Refer, Traversal of Singly Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Searching in Singly Linked List",
            "content": "Searching in a Singly Linked List refers to the process of looking for a specific element or value within the elements of the linked list.\nStep-by-step approach:\nStart from the head of the linked list.\nCheck each node’s data:\nIf it matches the target value, return true (element found).\nOtherwise, move to the next node.\nRepeat until the end (NULL) is reached.\nIf no match is found, return false.\nTo read more about Searching Operation in linked list Refer, Search an element in a Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Length of Singly Linked List",
            "content": "Finding the length of a Singly Linked List means counting the total number of nodes.\nStep-by-step approach:\nInitialize a counter (length = 0).\nStart from the head, assign it to current.\nTraverse the list:\nIncrement length for each node.\nMove to the next node (current = current->next).\nReturn the final length when current becomes NULL.\nTo read more about Finding Length of linked list Refer, Find Length of a Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Insertion in Singly Linked List",
            "content": "Insertion is a fundamental operation in linked lists that involves adding a new node to the list. There are several scenarios for insertion:\na. Insertion at the Beginning of Singly Linked List: Insertion at the beginning involves adding a new node before the current head, making it the new head.\nStep-by-step approach:\nCreate a new node with the given value.\nSet the next pointer of the new node to the current head.\nMove the head to point to the new node.\nReturn the new head of the linked list.\nTo read more about Insertion at the Beginning of linked list Refer, Insert a Node at Front/Beginning of a Linked List\nb. Insertion at the End of Singly Linked List: To insert a node at the end of the list, traverse the list until the last node is reached, and then link the new node to the current last node\nStep-by-step approach:\nCreate a new node with the given value.\nCheck if the list is empty:\nIf it is, make the new node the head and return.\nTraverse the list until the last node is reached.\nLink the new node to the current last node by setting the last node's next pointer to the new node.\nTo read more about Insertion at the end of linked list Refer, Insert Node at the End of a Linked List\nc. Insertion at a Specific Position of the Singly Linked List: To insert a node at a specific position, traverse the list to the desired position, link the new node to the next node, and update the links accordingly.\nStep-by-step approach:\nCreate a new node and assign it a value.\nIf inserting at the beginning (position = 1):\nPoint the new node’s next to the current head.\nUpdate the head to the new node.\nReturn (Insertion done).\nOtherwise, traverse the list:\nStart from the head and move to the (position - 1)ᵗʰ node (just before the desired position).\nIf the position is beyond the list length, return an error or append at the end.\nInsert the new node:\nPoint the new node’s next to the next node of the current position.\nUpdate the previous node’s next to the new node.\nReturn the updated list.\nTo read more about Insertion at the specific position of linked list Refer, Insert a node at a specific position in a linked list\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "5. Deletion in Singly Linked List",
            "content": "Deletion involves removing a node from the linked list. Similar to insertion, there are different scenarios for deletion:\na. Deletion at the Beginning of Singly Linked List: To delete the first node, update the head to point to the second node in the list.\nSteps-by-step approach:\nCheck if the head is NULL.\nIf it is, return NULL (the list is empty).\nStore the current head node in a temporary variable temp.\nMove the head pointer to the next node.\nDelete the temporary node.\nReturn the new head of the linked list.\nTo read more about Deletion at the beginning in linked list Refer, Deletion at beginning (Removal of first node) in a Linked List\nb. Deletion at the End of Singly Linked List: To delete the last node, traverse the list until the second-to-last node and update its next field to None.\nStep-by-step approach:\nCheck if the head is NULL.\nIf it is, return NULL (the list is empty).\nCheck if the head's next is NULL (only one node in the list).\nIf true, delete the head and return NULL.\nTraverse the list to find the second last node (second_last).\nDelete the last node (the node after second_last).\nSet the next pointer of the second last node to NULL.\nReturn the head of the linked list.\nTo read more about Deletion at the end in linked list Refer, Deletion at end (Removal of last node) in a Linked List\nc. Deletion at a Specific Position of Singly Linked List: To delete a node at a specific position, traverse the list to the desired position, update the links to bypass the node to be deleted.\nStep-by-step approach:\nCheck if the list is empty or the position is invalid, return if so.\nIf the head needs to be deleted, update the head and delete the node.\nTraverse to the node before the position to be deleted.\nIf the position is out of range, return.\nStore the node to be deleted.\nUpdate the links to bypass the node.\nDelete the stored node.\nTo read more about Deletion at the specific position in linked list Refer, Delete a Linked List node at a given position\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "6. Modify a Singly Linked List",
            "content": "Updating in a Singly Linked List means modifying the value of a node at a given position.\nStep-by-step approach:\nStart from the head of the list.\nTraverse to the required position (move current node to position).\nCheck if the position is valid:\nIf the position is out of bounds, return an error.\nUpdate the node’s data with the new value.\nReturn the modified list.\nTo read more about Updation Operation in Linked List Refer, Modify contents of Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "7. Reversing a Singly Linked List",
            "content": "Reversing a singly linked list means changing the direction of pointers so that the last node becomes the new head.\nStep-by-step approach:\nInitialize three pointers:\nprev = NULL (to track the previous node)\ncurrent = head (starting point)\nnext = NULL (to store the next node temporarily)\nIterate through the list:\nStore next = current->next (save next node).\nReverse the link: current->next = prev.\nMove prev and current forward (prev = current, current = next).\nUpdate head to prev (new head is the last node).\nTo read more about Reversal Operation in Linked List Refer, Reverse a Linked List\n",
            "code_snippets": {
              "cpp": "// Definition of a Node in a singly linked liststruct Node {      // Data part of the node    int data;    // Pointer to the next node in the list    Node* next;    // Constructor to initialize the node with data    Node(int data)    {        this->data = data;        this->next = nullptr;    }};",
              "c": "// Definition of a Node in a singly linked liststruct Node {    int data;              struct Node* next;};// Function to create a new Nodestruct Node* newNode(int data) {    struct Node* temp =       (struct Node*)malloc(sizeof(struct Node));    temp->data = data;    temp->next = NULL;    return temp;}",
              "java": "// Definition of a Node in a singly linked listpublic classNode {    int data;    Node next;    // Constructor to initialize the node with data    public Node(int data)    {        this.data = data;        this.next = null;    }}",
              "python3": "# Definition of a Node in a singly linked listclassNode:def__init__(self,data):# Data part of the nodeself.data=dataself.next=None",
              "javascript": "// Definition of a Node in a singly linked listclass Node {    constructor(data) {    // Data part of the node        this.data = data;           this.next = null;       }}"
            }
          }
        ]
      },
      {
        "subtopic_title": "Applications, Advantages and Disadvantages of Linked List",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-linked-list/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Advantages of Linked Lists (or Most Common Use Cases):",
            "content": "Linked Lists are mostly used because of their effective insertion and deletion.  We only need to change few pointers (or references) to insert (or delete) an item in the middle\nInsertion and deletion at any point in a linked list take O(1) time. Whereas in an array data structure, insertion / deletion in the middle takes O(n) time.\nThis data structure is simple and can be also used to implement a stack, queues, and other abstract data structures.\nImplementation of Queue and Deque data structures : Simple array implementation is not efficient at all. We must use circular array to efficiently implement which is complex. But with linked list, it is easy and straightforward. That is why most of the language libraries use Linked List internally to implement these data structures..\nLinked List might turn out to be more space efficient compare to arrays in cases where we cannot guess the number of elements in advance. In case of arrays, the whole memory for items is allocated together. Even with dynamic sized arrays like vector in C++ or list in Python or ArrayList in Java. the internal working involves de-allocation of whole memory and allocation of a bigger chunk when insertions happen beyond the current capacity.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Linked Lists:",
            "content": "Linked Lists can be used to implement stacks, queue, deque, sparse matrices and adjacency list representation of graphs.\nDynamic memory allocation in operating systems and compilers (linked list of free blocks).\nManipulation of polynomials\nArithmetic operations on long integers.\nIn operating systems, they can be used in Memory management, process scheduling (for example circular linked list for round robin scheduling) and file system.\nAlgorithms that need to frequently insert or delete items from large collections of data.\nLRU cache, which uses a doubly linked list to keep track of the most recently used items in a cache.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Linked Lists in real world:",
            "content": "The list of songs in the music player are linked to the previous and next songs. \nIn a web browser, previous and next web page URLs can be linked through the previous and next buttons (Doubly Linked List)\nIn image viewer, the previous and next images can be linked with the help of the previous and next buttons (Doubly Linked List)\nCircular Linked Lists can be used to implement things in round manner where we go to every element one by one.\nLinked List are preferred over arrays for implementations of Queue and Deque data structures because of fast deletions (or insertions) from the front of the linked lists.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Linked Lists:",
            "content": "Linked lists are a popular data structure in computer science, but like any other data structure, they have certain disadvantages as well. Some of the key disadvantages of linked lists are:\nSlow Access Time: Accessing elements in a linked list can be slow, as you need to traverse the linked list to find the element you are looking for, which is an O(n) operation. This makes linked lists a poor choice for situations where you need to access elements quickly.\nPointers or References: Linked lists use pointers or references to access the next node, which can make them more complex to understand and use compared to arrays. This complexity can make linked lists more difficult to debug and maintain.\nHigher overhead: Linked lists have a higher overhead compared to arrays, as each node in a linked list requires extra memory to store the reference to the next node.\nCache Inefficiency: Linked lists are cache-inefficient because the memory is not contiguous. This means that when you traverse a linked list, you are not likely to get the data you need in the cache, leading to cache misses and slow performance.\nIn conclusion, linked lists are a powerful and flexible data structure, but they have certain disadvantages that need to be taken into consideration when deciding whether to use them or not. For example, if you need fast access time, arrays might be a better choice, but if you need to insert or delete elements frequently, linked lists might be the better choice.\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "14. Stack",
    "main_article_link": "https://www.geeksforgeeks.org/stack-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Implement Stack using Array",
        "subtopic_url": "https://www.geeksforgeeks.org/implement-stack-using-array/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Push Operation in Stack:",
            "content": "Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.\nBefore pushing the element to the stack, we check if the stack is full .\nIf the stack is full (top == capacity-1) , then Stack Overflows and we cannot insert the element to the stack.\nOtherwise, we increment the value of top by 1 (top = top + 1) and the new value is inserted at top position .\nThe elements can be pushed into the stack till we reach the capacity of the stack.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Pop Operation in Stack:",
            "content": "Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.\nBefore popping the element from the stack, we check if the stack is empty .\nIf the stack is empty (top == -1), then Stack Underflows and we cannot remove any element from the stack.\nOtherwise, we store the value at top, decrement the value of top by 1 (top = top – 1) and return the stored top value.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Top or Peek Operation in Stack:",
            "content": "Returns the top element of the stack.\nBefore returning the top element from the stack, we check if the stack is empty.\nIf the stack is empty (top == -1), we simply print “Stack is empty”.\nOtherwise, we return the element stored at index = top .\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "isEmpty Operation in Stack:",
            "content": "Returns true if the stack is empty, else false.=\nCheck for the value of top in stack.\nIf (top == -1) , then the stack is empty so return true .\nOtherwise, the stack is not empty so return false .\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "isFull",
            "content": "Returns true if the stack is full, else false.\nCheck for the value of top in stack.\nIf (top == capacity-1), then the stack is full so return true .\nOtherwise, the stack is not full so return false.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation using Fixed Sized Array",
            "content": "In this implementation, we use a fixed sized array. We take capacity as argument when we create a stack. We create an array with size equal to given capacity. If number of elements go beyond capacity, we throw an overflow error.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation using Dynamic Sized Array",
            "content": "In this implementation, we use a dynamic sized array like vector in C++, ArrayList in Java, List in Python and Array in JavaScript. This is a simpler implementation but less efficient compared to the previous one if we know capacity in advance.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Comparison of the two Implementations",
            "content": "The first implementation should be preferred if we know capacity or have a close upper bound on number of elements.\nThe second one is simple and has amortized (average over n operations) time complexities as O(1) for push and pop. However it can have a particular push and pop very costly.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Complexity Analysis:",
            "content": "Time Complexity:\npush: O(1)\npop: O(1)\npeek: O(1)\nis_empty: O(1)\nis_full: O(1)\nAuxiliary Space: O(n), where n is the number of items in the stack.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Array Implementation:",
            "content": "Easy to implement.\nMemory is saved as pointers are not involved.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Array Implementation:",
            "content": "It is not dynamic i.e., it doesn’t grow and shrink depending on needs at runtime. [But in case of dynamic sized arrays like vector in C++, list in Python, ArrayList in Java, stacks can grow and shrink with array implementation as well]. But with dynamic sized arrays, we get amortized time complexity as O(1), not the worst case. If we use linked list, we get worst case time complexities as O(1).\nThe total size of the stack must be defined beforehand.\n",
            "code_snippets": {
              "cpp": "#include <bits/stdc++.h>using namespace std;int main() {    vector<int> s;    // Push elements    s.push_back(10);    s.push_back(20);    s.push_back(30);    // Pop and print the top element    cout << s.back() << \" popped from stack\\n\";    s.pop_back();    // Peek at the top element    cout << \"Top element is: \" << s.back() << endl;    // Print all elements in the stack    cout << \"Elements present in stack: \";    while (!s.empty()) {        cout << s.back() << \" \";        s.pop_back();    }    return 0;}",
              "c": "// C program to create a stack with given capacity#include <stdio.h>#include <stdlib.h>struct Stack {    int top, cap;    int *a;};struct Stack* createStack(int cap) {    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));    stack->cap = cap;    stack->top = -1;    stack->a = (int*)malloc(cap * sizeof(int));    return stack;}void deleteStack(struct Stack* stack) {    free(stack->a);    free(stack);}int isFull(struct Stack* stack) {    return stack->top >= stack->cap - 1;}int isEmpty(struct Stack* stack) {    return stack->top < 0;}int push(struct Stack* stack, int x) {    if (isFull(stack)) {        printf(\"Stack Overflow\\n\");        return 0;    }    stack->a[++stack->top] = x;    return 1;}int pop(struct Stack* stack) {    if (isEmpty(stack)) {        printf(\"Stack Underflow\\n\");        return 0;    }    return stack->a[stack->top--];}int peek(struct Stack* stack) {    if (isEmpty(stack)) {        printf(\"Stack is Empty\\n\");        return 0;    }    return stack->a[stack->top];}int main() {    struct Stack* s = createStack(5);    push(s, 10);    push(s, 20);    push(s, 30);    printf(\"%d popped from stack\\n\", pop(s));    printf(\"Top element is: %d\\n\", peek(s));    printf(\"Elements present in stack: \");    while (!isEmpty(s)) {        printf(\"%d \", peek(s));        pop(s);    }    deleteStack(s);    return 0;}",
              "java": "import java.util.ArrayList;public classMain {    public static void main(String[] args) {        ArrayList<Integer> s = new ArrayList<>();        // Push elements        s.add(10);        s.add(20);        s.add(30);        // Pop and print the top element        System.out.println(s.get(s.size() - 1) + \" popped from stack\");        s.remove(s.size() - 1);        // Peek at the top element        System.out.println(\"Top element is: \" + s.get(s.size() - 1));        // Print all elements in the stack        System.out.print(\"Elements present in stack: \");        while (!s.isEmpty()) {            System.out.print(s.get(s.size() - 1) + \" \");            s.remove(s.size() - 1);        }    }}",
              "python3": "s=[]# Push elementss.append(10)s.append(20)s.append(30)# Pop and print the top elementprint(f'{s[-1]} popped from stack')s.pop()# Peek at the top elementprint(f'Top element is: {s[-1]}')# Print all elements in the stackprint('Elements present in stack: ',end='')whiles:print(s.pop(),end=' ')",
              "csharp": "using System;using System.Collections.Generic;class GfG {    static void Main() {        Stack<int> s = new Stack<int>();        // Push elements        s.Push(10);        s.Push(20);        s.Push(30);        // Pop and print the top element        Console.WriteLine(s.Peek() + \" popped from stack\");        s.Pop();        // Peek at the top element        Console.WriteLine(\"Top element is: \" + s.Peek());        // Print all elements in the stack        Console.WriteLine(\"Elements present in stack: \");        while (s.Count > 0) {            Console.Write(s.Pop() + \" \");        }    }}",
              "javascript": "// Using an array to simulate stack behaviorlet s = [];// Push elementss.push(10);s.push(20);s.push(30);// Pop and print the top elementconsole.log(s[s.length - 1] + \" popped from stack\");s.pop();// Peek at the top elementconsole.log(\"Top element is: \" + s[s.length - 1]);// Print all elements in the stackconsole.log(\"Elements present in stack: \");while (s.length > 0) {    console.log(s[s.length - 1] + \" \");    s.pop();}"
            }
          }
        ]
      },
      {
        "subtopic_title": "Applications, Advantages and Disadvantages of Stack",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-stack/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Applications of Stacks:",
            "content": "Function calls: Stacks are used to keep track of the return addresses of function calls, allowing the program to return to the correct location after a function has finished executing.\nRecursion: Stacks are used to store the local variables and return addresses of recursive function calls, allowing the program to keep track of the current state of the recursion.\nExpression evaluation: Stacks are used to evaluate expressions in postfix notation (Reverse Polish Notation).\nSyntax parsing: Stacks are used to check the validity of syntax in programming languages and other formal languages.\nMemory management: Stacks are used to allocate and manage memory in some operating systems and programming languages.\nUsed to solve popular problems like Next Greater, Previous Greater, Next Smaller, Previous Smaller, Largest Area in a Histogram and Stock Span Problems.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Stacks:",
            "content": "Simplicity: Stacks are a simple and easy-to-understand data structure, making them suitable for a wide range of applications.\nEfficiency: Push and pop operations on a stack can be performed in constant time (O(1)), providing efficient access to data.\nLast-in, First-out (LIFO): Stacks follow the LIFO principle, ensuring that the last element added to the stack is the first one removed. This behavior is useful in many scenarios, such as function calls and expression evaluation.\nLimited memory usage: Stacks only need to store the elements that have been pushed onto them, making them memory-efficient compared to other data structures.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Disadvantages of Stacks:",
            "content": "Limited access: Elements in a stack can only be accessed from the top, making it difficult to retrieve or modify elements in the middle of the stack.\nPotential for overflow: If more elements are pushed onto a stack than it can hold, an overflow error will occur, resulting in a loss of data.\nNot suitable for random access: Stacks do not allow for random access to elements, making them unsuitable for applications where elements need to be accessed in a specific order.\nLimited capacity: Stacks have a fixed capacity, which can be a limitation if the number of elements that need to be stored is unknown or highly variable.\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Stack Implementation using Deque",
        "subtopic_url": "https://www.geeksforgeeks.org/stack-implementation-using-deque/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "What is Stack Data Structure? A Complete Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "LIFO(Last In First Out) Principle",
            "content": "Here are some real world examples of LIFO\nConsider a stack of plates. When we add a plate, we add at the top. When we remove, we remove from the top.\nA shuttlecock box (or any other box that is closed from one end) is another great real-world example of the LIFO (Last In, First Out) principle where do insertions and removals from the same end.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Stack Data Structure:",
            "content": "Stack follows LIFO (Last In First Out) Principle so the element which is pushed last is popped first.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Stack:",
            "content": "Fixed Size Stack : As the name suggests, a fixed size stack has a fixed size and cannot grow or shrink dynamically. If the stack is full and an attempt is made to add an element to it, an overflow error occurs. If the stack is empty and an attempt is made to remove an element from it, an underflow error occurs.\nDynamic Size Stack : A dynamic size stack can grow or shrink dynamically. When the stack is full, it automatically increases its size to accommodate the new element, and when the stack is empty, it decreases its size. This type of stack is implemented using a linked list, as it allows for easy resizing of the stack.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Basic Operations on Stack:",
            "content": "In order to make manipulations in a stack, there are certain operations provided to us.\npush() to insert an element into the stack\npop() to remove an element from the stack\ntop() Returns the top element of the stack.\nisEmpty() returns true if stack is empty else false.\nisFull() returns true if the stack is full else false.\nTo implement stack, we need to maintain reference to the top item.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Push Operation on Stack",
            "content": "Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.\nAlgorithm for Push Operation:\nBefore pushing the element to the stack, we check if the stack is full .\nIf the stack is full (top == capacity-1) , then Stack Overflows and we cannot insert the element to the stack.\nOtherwise, we increment the value of top by 1 (top = top + 1) and the new value is inserted at top position .\nThe elements can be pushed into the stack till we reach the capacity of the stack.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Pop Operation in Stack",
            "content": "Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.\nAlgorithm for Pop Operation:\nBefore popping the element from the stack, we check if the stack is empty .\nIf the stack is empty (top == -1), then Stack Underflows and we cannot remove any element from the stack.\nOtherwise, we store the value at top, decrement the value of top by 1 (top = top – 1) and return the stored top value.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Top or Peek Operation on Stack",
            "content": "Returns the top element of the stack.\nAlgorithm for Top Operation:\nBefore returning the top element from the stack, we check if the stack is empty.\nIf the stack is empty (top == -1), we simply print “Stack is empty”.\nOtherwise, we return the element stored at index = top .\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "isEmpty Operation in Stack Data Structure:",
            "content": "Returns true if the stack is empty, else false.\nAlgorithm for isEmpty Operation:\nCheck for the value of top in stack.\nIf (top == -1), then the stack is empty so return true .\nOtherwise, the stack is not empty so return false .\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "isFull",
            "content": "Returns true if the stack is full, else false.\nAlgorithm for isFull Operation:\nCheck for the value of top in stack.\nIf (top == capacity-1), then the stack is full so return true.\nOtherwise, the stack is not full so return false.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of Stack",
            "content": "The basic operations that can be performed on a stack include push, pop, and peek. There are two ways to implement a stack –\nImplementation of Stack using Array\nImplementation of Stack using Linked List\nImplementation of Stack using Deque\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Complexity Analysis of Operations on Stack Data Structure:",
            "content": "Next Articles:\nApplications, Advantages and Disadvantages of Stack\nImplement a stack using singly linked list\nBasic Operations in Stack Data Structure with Implementations\nTop 50 Problems on Stack Data Structure asked in SDE Interviews\nApplications, Advantages and Disadvantages of Stack\nStack for Competitive Programming\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Implement a stack using singly linked list",
        "subtopic_url": "https://www.geeksforgeeks.org/implement-a-stack-using-singly-linked-list/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Stack Operations",
            "content": "push(): Insert a new element into the stack (i.e just insert a new element at the beginning of the linked list.)\npop(): Return the top element of the Stack (i.e simply delete the first element from the linked list.)\npeek(): Return the top element.\ndisplay(): Print all elements in Stack.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Push Operation",
            "content": "Initialise a node\nUpdate the value of that node by data i.e. node->data = data\nNow link this node to the top of the linked list\nAnd update top pointer to the current node\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Pop Operation",
            "content": "First Check whether there is any node present in the linked list or not, if not then return\nOtherwise make pointer let say temp to the top node and move forward the top node by 1 step\nNow free this temp node\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Peek Operation",
            "content": "Check if there is any node present or not, if not then return.\nOtherwise return the value of top node of the linked list\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Display Operation",
            "content": "Take a temp node and initialize it with top pointer \nNow start traversing temp till it encounters NULL\nSimultaneously print the value of the temp node\nTime Complexity: O(1), for all push(), pop(), and peek(), as we are not performing any kind of traversal over the list.\nAuxiliary Space: O(n), where n is the size of the stack\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Benefits of implementing a stack using a singly linked list",
            "content": "Dynamic memory allocation: The size of the stack can be increased or decreased dynamically by adding or removing nodes from the linked list, without the need to allocate a fixed amount of memory for the stack upfront.\nEfficient memory usage: Since nodes in a singly linked list only have a next pointer and not a prev pointer, they use less memory than nodes in a doubly linked list.\nEasy implementation: Implementing a stack using a singly linked list is straightforward and can be done using just a few lines of code.\nVersatile: Singly linked lists can be used to implement other data structures such as queues, linked lists, and trees.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Real time examples of stack",
            "content": "Stacks are used in various real-world scenarios where a last-in, first-out (LIFO) data structure is required. Here are some examples of real-time applications of stacks:\nFunction Call Stack: When a function is called, its return address and parameters are pushed onto the stack. The stack ensures functions execute and return in reverse order..\nUndo/Redo Operations: In apps like text or image editors, actions are pushed onto a stack. Undo removes the last action, while redo restores it.\nBrowser History: Browsers use stacks to track visited pages. Visiting a page pushes its URL onto the stack, and the “Back” button pops the last URL to go to the previous page.\nExpression Evaluation: In compilers, expressions are converted to postfix notation and evaluated using a stack.\nCall Stack in Recursion: Recursive function calls are pushed onto the stack. Once recursion ends, the stack is popped to return to the previous function call.\n",
            "code_snippets": {
              "cpp": "#include <bits/stdc++.h>using namespace std;class Node {public:    int data;    Node* next;    Node(int new_data) {        this->data = new_data;        this->next = nullptr;    }};class Stack {    Node* head;public:    Stack() { this->head = nullptr; }    bool isEmpty() {        return head == nullptr;    }    void push(int new_data) {        Node* new_node = new Node(new_data);        if (!new_node) {            cout << \"\\nStack Overflow\";        }        new_node->next = head;        head = new_node;    }    void pop() {        if (this->isEmpty()) {            cout << \"\\nStack Underflow\" << endl;        } else {            Node* temp = head;            head = head->next;            delete temp;        }    }    int peek() {        if (!isEmpty())            return head->data;        else {            cout << \"\\nStack is empty\";            return INT_MIN;        }    }};int main() {    Stack st;    st.push(11);    st.push(22);    st.push(33);    st.push(44);    cout << \"Top element is \" << st.peek() << endl;    cout << \"Removing two elements...\" << endl;    st.pop();    st.pop();    cout << \"Top element is \" << st.peek() << endl;    return 0;}",
              "c": "// C program to implement a stack using singly linked list#include <limits.h>#include <stdio.h>#include <stdlib.h>// Struct representing a node in the linked listtypedef struct Node {    int data;    struct Node* next;} Node;Node* createNode(int new_data) {    Node* new_node = (Node*)malloc(sizeof(Node));    new_node->data = new_data;    new_node->next = NULL;    return new_node;}// Struct to implement stack using a singly linked listtypedef struct Stack {    Node* head;} Stack;// Constructor to initialize the stackvoid initializeStack(Stack* stack) { stack->head = NULL; }// Function to check if the stack is emptyint isEmpty(Stack* stack) {      // If head is NULL, the stack is empty    return stack->head == NULL;}// Function to push an element onto the stackvoid push(Stack* stack, int new_data) {      // Create a new node with given data    Node* new_node = createNode(new_data);    // Check if memory allocation for the new node failed    if (!new_node) {        printf(\"\\nStack Overflow\");        return;    }    // Link the new node to the current top node    new_node->next = stack->head;    // Update the top to the new node    stack->head = new_node;}// Function to remove the top element from the stackvoid pop(Stack* stack) {      // Check for stack underflow    if (isEmpty(stack)) {        printf(\"\\nStack Underflow\\n\");        return;    }    else {              // Assign the current top to a temporary variable        Node* temp = stack->head;        // Update the top to the next node        stack->head = stack->head->next;        // Deallocate the memory of the old top node        free(temp);    }}// Function to return the top element of the stackint peek(Stack* stack) {      // If stack is not empty, return the top element    if (!isEmpty(stack))        return stack->head->data;    else {        printf(\"\\nStack is empty\");        return INT_MIN;    }}// Driver program to test the stack implementationint main() {      // Creating a stack    Stack stack;    initializeStack(&stack);    // Push elements onto the stack    push(&stack, 11);    push(&stack, 22);    push(&stack, 33);    push(&stack, 44);    // Print top element of the stack    printf(\"Top element is %d\\n\", peek(&stack));    \t// removing two elemements from the top  \tprintf(\"Removing two elements...\\n\");    pop(&stack);    pop(&stack);    // Print top element of the stack    printf(\"Top element is %d\\n\", peek(&stack));    return 0;}",
              "java": "// Java program to implement a stack using singly linked// list// Class representing a node in the linked listclassNode {    int data;    Node next;    Node(int new_data) {        this.data = new_data;        this.next = null;    }}// Class to implement stack using a singly linked listclassStack {    // Head of the linked list    Node head;    // Constructor to initialize the stack    Stack() { this.head = null; }    // Function to check if the stack is empty    boolean isEmpty() {              // If head is null, the stack is empty        return head == null;    }    // Function to push an element onto the stack    void push(int new_data) {              // Create a new node with given data        Node new_node = new Node(new_data);        // Check if memory allocation for the new node        // failed        if (new_node == null) {            System.out.println(\"\\nStack Overflow\");            return;        }        // Link the new node to the current top node        new_node.next = head;        // Update the top to the new node        head = new_node;    }    // Function to remove the top element from the stack    void pop() {              // Check for stack underflow        if (isEmpty()) {            System.out.println(\"\\nStack Underflow\");            return;        }        else {                      // Assign the current top to a temporary            // variable            Node temp = head;            // Update the top to the next node            head = head.next;            // Deallocate the memory of the old top node            temp = null;        }    }    // Function to return the top element of the stack    int peek() {              // If stack is not empty, return the top element        if (!isEmpty())            return head.data;        else {            System.out.println(\"\\nStack is empty\");            return Integer.MIN_VALUE;        }    }}// Driver codepublic classMain {    public static void main(String[] args)    {        // Creating a stack        Stack st = new Stack();        // Push elements onto the stack        st.push(11);        st.push(22);        st.push(33);        st.push(44);        // Print top element of the stack        System.out.println(\"Top element is \" + st.peek());        // removing two elemements from the top  \t\tSystem.out.println(\"Removing two elements...\");        st.pop();        st.pop();        // Print top element of the stack        System.out.println(\"Top element is \" + st.peek());    }}",
              "python3": "# Java program to implement a stack using singly linked# list# Class representing a node in the linked listclassNode:def__init__(self,new_data):self.data=new_dataself.next=None# Class to implement stack using a singly linked listclassStack:def__init__(self):# head of the linked listself.head=None# Function to check if the stack is emptydefis_empty(self):# If head is None, the stack is emptyreturnself.headisNone# Function to push an element onto the stackdefpush(self,new_data):# Create a new node with given datanew_node=Node(new_data)# Check if memory allocation for the new node failedifnotnew_node:print(\"\\nStack Overflow\")return# Link the new node to the current top nodenew_node.next=self.head# Update the top to the new nodeself.head=new_node# Function to remove the top element from the stackdefpop(self):# Check for stack underflowifself.is_empty():print(\"\\nStack Underflow\")else:# Assign the current top to a temporary variabletemp=self.head# Update the top to the next nodeself.head=self.head.next# Deallocate the memory of the old top nodedeltemp# Function to return the top element of the stackdefpeek(self):# If stack is not empty, return the top elementifnotself.is_empty():returnself.head.dataelse:print(\"\\nStack is empty\")returnfloat('-inf')# Creating a stackst=Stack()# Push elements onto the stackst.push(11)st.push(22)st.push(33)st.push(44)# Print top element of the stackprint(\"Top element is\",st.peek())# removing two elemements from the topprint(\"Removing two elements...\");st.pop()st.pop()# Print top element of the stackprint(\"Top element is\",st.peek())",
              "csharp": "// C# program to implement a stack using singly linked listusing System;// Class representing a node in the linked listclass Node {    public int data;    public Node next;    public Node(int new_data)    {        this.data = new_data;        this.next = null;    }}// Class to implement stack using a singly linked listclass Stack {    // head of the linked list    private Node head;    // Constructor to initialize the stack    public Stack() { this.head = null; }    // Function to check if the stack is empty    public bool isEmpty()    {        // If head is null, the stack is empty        return head == null;    }    // Function to push an element onto the stack    public void push(int new_data)    {        // Create a new node with given data        Node new_node = new Node(new_data);        // Check if memory allocation for the new node        // failed        if (new_node == null) {            Console.WriteLine(\"\\nStack Overflow\");            return;        }        // Link the new node to the current top node        new_node.next = head;        // Update the top to the new node        head = new_node;    }    // Function to remove the top element from the stack    public void pop()    {        // Check for stack underflow        if (this.isEmpty()) {            Console.WriteLine(\"\\nStack Underflow\");        }        else {            // Update the top to the next node            head = head.next;            /* No need to manually free the memory of the             * old head in C# */        }    }    // Function to return the top element of the stack    public int peek()    {        // If stack is not empty, return the top element        if (!isEmpty())            return head.data;        else {            Console.WriteLine(\"\\nStack is empty\");            return int.MinValue;        }    }}// Driver program to test the stack implementationclass GfG {    static void Main(string[] args)    {        // Creating a stack        Stack st = new Stack();        // Push elements onto the stack        st.push(11);        st.push(22);        st.push(33);        st.push(44);        // Print top element of the stack        Console.WriteLine(\"Top element is \" + st.peek());        // removing two elemements from the top  \t\tConsole.WriteLine(\"Removing two elements...\");        st.pop();        st.pop();        // Print top element of the stack        Console.WriteLine(\"Top element is \" + st.peek());    }}",
              "javascript": "// Javascript program to implement a stack using singly// linked list// Class representing a node in the linked listclass Node {    constructor(new_data) {        this.data = new_data;        this.next = null;    }}// Class to implement stack using a singly linked listclass Stack {    // Constructor to initialize the stack    constructor() { this.head = null; }    // Function to check if the stack is empty    isEmpty() {            // If head is null, the stack is empty        return this.head === null;    }    // Function to push an element onto the stack    push(new_data) {            // Create a new node with given data        const new_node = new Node(new_data);        // Check if memory allocation for the new node        // failed        if (!new_node) {            console.log(\"\\nStack Overflow\");            return;        }        // Link the new node to the current top node        new_node.next = this.head;        // Update the top to the new node        this.head = new_node;    }    // Function to remove the top element from the stack    pop() {            // Check for stack underflow        if (this.isEmpty()) {            console.log(\"\\nStack Underflow\");        }        else {                    // Assign the current top to a temporary            // variable            let temp = this.head;            // Update the top to the next node            this.head = this.head.next;            // Deallocate the memory of the old top node            temp = null;        }    }    // Function to return the top element of the stack    peek() {            // If stack is not empty, return the top element        if (!this.isEmpty())            return this.head.data;        else {            console.log(\"\\nStack is empty\");            return Number.MIN_VALUE;        }    }}// Driver program to test the stack implementationconst st = new Stack();// Push elements onto the stackst.push(11);st.push(22);st.push(33);st.push(44);// Print top element of the stackconsole.log(\"Top element is \" + st.peek());// removing two elemements from the topconsole.log(\"Removing two elements...\");st.pop();st.pop();// Print top element of the stackconsole.log(\"Top element is \" + st.peek());"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "15. Queue",
    "main_article_link": "https://www.geeksforgeeks.org/queue-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Applications, Advantages and Disadvantages of Queue",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-queue/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Introduction and Array Implementation of Queue",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-and-array-implementation-of-queue/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Simple Array implementation Of Queue:",
            "content": "For implementing the queue, we only need to keep track of two variables: front and size. We can find the rear as front + size - 1.\nThe Enqueue operation is simple, we simply insert at the end of the array. This operation takes O(1) time\nThe Dequeue operation is costly as we need remove from the beginning of the array. To remove an item, we need to move all items one position back. Hence this operations takes O(n) time.\nIf we do otherwise that insert at the begin and delete from the end, then insert would become costly.\nPlease refer Simple Array implementation of Queue for implementation.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Circular Array implementation Of Queue:",
            "content": "We can make all operations in O(1) time using circular array implementation.\nThe idea is to treat the array as a circular buffer. We move front and rear using modular arithmetic\nWhen we insert an item, we increment front using modular arithmetic (which might leave some free space at the beginning of the array).\nWhen we delete an item, we decrement rear using modular arithmetic.\nPlease refer Circular Array implementation Of Queue for details of implementation\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Basic Operations for Queue in Data Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/basic-operations-for-queue-in-data-structure/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Basic Operations on Queue",
            "content": "Some of the basic operations for Queue in Data Structure are:\nenqueue() - Insertion of elements to the queue.\ndequeue() - Removal of elements from the queue.\ngetFront()- Acquires the data element available at the front node of the queue without deleting it.\ngetRear() - This operation returns the element at the rear end without removing it.\nisFull() - Validates if the queue is full.\nisEmpty() - Checks if the queue is empty.\nsize() - This operation returns the size of the queue i.e. the total number of elements it contains.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 1: enqueue()",
            "content": "Inserts an element at the end of the queue i.e. at the rear end.\nThe following steps should be taken to enqueue (insert) data into a queue:\nCheck if the queue is full.\nIf the queue is full, return overflow error and exit.\nIf the queue is not full, increment the rear pointer to point to the next empty space.\nAdd the data element to the queue location, where the rear is pointing.\nreturn success.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 2: dequeue()",
            "content": "This operation removes and returns an element that is at the front end of the queue.\nThe following steps are taken to perform the dequeue operation:\nCheck if the queue is empty.\nIf the queue is empty, return the underflow error and exit.\nIf the queue is not empty, access the data where the front is pointing.\nIncrement the front pointer to point to the next available data element.\nThe Return success.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 3:",
            "content": "This operation returns the element at the front end of the queue without removing it.\nThe following steps are taken to perform the getFront() operation:\nIf the queue is empty, return the most minimum value (e.g., -1).\nOtherwise, return the front value of the queue.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 4: getRear()",
            "content": "This operation returns the element at the rear end without removing it.\nThe following steps are taken to perform the rear operation:\nIf the queue is empty return the most minimum value.\notherwise, return the rear value.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 5: isEmpty()",
            "content": "This operation returns a boolean value that indicates whether the queue is empty or not.\nThe following steps are taken to perform the Empty operation:\ncheck if front value is equal to -1 or not, if yes then return true means queue is empty.\nOtherwise return false, means queue is not empty.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operation 6: size()",
            "content": "This operation returns the size of the queue i.e. the total number of elements it contains.\nCode Implementation of all the operations:\n",
            "code_snippets": {
              "cpp": "#include <iostream>#include <queue>using namespace std;queue<int> q;bool isEmpty(){    return q.empty();}void qEnqueue(int data){    q.push(data);}void qDequeue(){    if (isEmpty()) {        return;    }    q.pop();}int getFront(){    if (isEmpty()) return -1;    return q.front();}int getRear(){    if (isEmpty()) return -1;    return q.back();}int main(){    qEnqueue(1);    qEnqueue(8);    qEnqueue(3);    qEnqueue(6);    qEnqueue(2);    if (!isEmpty()) {        cout << \"Queue after enqueue operation: \";        queue<int> tempQueue = q;         while (!tempQueue.empty()) {            cout << tempQueue.front() << \" \";            tempQueue.pop();        }        cout << endl;    }    cout << \"Front: \" << getFront() << endl;    cout << \"Rear: \" << getRear() << endl;    cout << \"Queue size: \" << q.size() << endl;    qDequeue();    cout << \"Is queue empty? \" << (isEmpty() ? \"Yes\" : \"No\") << endl;    return 0;}",
              "java": "import java.util.LinkedList;import java.util.Queue;public classGfG {    static Queue<Integer> q = new LinkedList<>();    static boolean isEmpty() {        return q.isEmpty();    }    static void qEnqueue(int data) {        q.add(data);    }    static void qDequeue() {        if (isEmpty()) {            return;        }        q.poll();    }    static int getFront() {        if (isEmpty()) return -1;        return q.peek();    }    static int getRear() {        if (isEmpty()) return -1;        return ((LinkedList<Integer>) q).getLast();    }    public static void main(String[] args) {        qEnqueue(1);        qEnqueue(8);        qEnqueue(3);        qEnqueue(6);        qEnqueue(2);        if (!isEmpty()) {            System.out.print(\"Queue after enqueue operation: \");            for (int num : q) {                System.out.print(num + \" \");            }            System.out.println();        }        System.out.println(\"Front: \" + getFront());        System.out.println(\"Rear: \" + getRear());        System.out.println(\"Queue size: \" + q.size());        qDequeue();        System.out.println(\"Is queue empty? \" + (isEmpty() ? \"Yes\" : \"No\"));    }}",
              "python3": "# Importing necessary modulesfromcollectionsimportdequeq=deque()defisEmpty():returnlen(q)==0defqEnqueue(data):q.append(data)defqDequeue():ifisEmpty():returnq.popleft()defgetFront():ifisEmpty():return-1returnq[0]defgetRear():ifisEmpty():return-1returnq[-1]if__name__=='__main__':qEnqueue(1)qEnqueue(8)qEnqueue(3)qEnqueue(6)qEnqueue(2)ifnotisEmpty():print(\"Queue after enqueue operation: \",list(q))print(\"Front: \",getFront())print(\"Rear: \",getRear())print(\"Queue size: \",len(q))qDequeue()print(\"Is queue empty? \",\"Yes\"ifisEmpty()else\"No\")",
              "csharp": "// Importing necessary namespacesusing System;using System.Collections.Generic;class GfG {    static Queue<int> q = new Queue<int>();    static bool IsEmpty() {        return q.Count == 0;    }    static void QEnqueue(int data) {        q.Enqueue(data);    }    static void QDequeue() {        if (IsEmpty()) {            return;        }        q.Dequeue();    }    static int GetFront() {        if (IsEmpty()) return -1;        return q.Peek();    }    static int GetRear() {        if (IsEmpty()) return -1;        return q.ToArray()[q.Count - 1];    }    static void Main() {        QEnqueue(1);        QEnqueue(8);        QEnqueue(3);        QEnqueue(6);        QEnqueue(2);        if (!IsEmpty()) {            Console.WriteLine(\"Queue after enqueue operation: \" + string.Join(\" \", q));        }        Console.WriteLine(\"Front: \" + GetFront());        Console.WriteLine(\"Rear: \" + GetRear());        Console.WriteLine(\"Queue size: \" + q.Count);        QDequeue();        Console.WriteLine(\"Is queue empty? \" + (IsEmpty() ? \"Yes\" : \"No\"));    }}",
              "javascript": "// Using a class to implement a queueclass Queue {    constructor() {        this.items = [];    }    isEmpty() {        return this.items.length === 0;    }    enqueue(data) {        this.items.push(data);    }    dequeue() {        if (this.isEmpty()) {            return;        }        this.items.shift();    }    getFront() {        if (this.isEmpty()) return -1;        return this.items[0];    }    getRear() {        if (this.isEmpty()) return -1;        return this.items[this.items.length - 1];    }    size() {        return this.items.length;    }}const q = new Queue();q.enqueue(1);q.enqueue(8);q.enqueue(3);q.enqueue(6);q.enqueue(2);if (!q.isEmpty()) {    console.log('Queue after enqueue operation: ', q.items);}console.log('Front: ', q.getFront());console.log('Rear: ', q.getRear());console.log('Queue size: ', q.size());q.dequeue();console.log('Is queue empty? ', q.isEmpty() ? 'Yes' : 'No');"
            }
          }
        ]
      },
      {
        "subtopic_title": "Queue - Linked List Implementation",
        "subtopic_url": "https://www.geeksforgeeks.org/queue-linked-list-implementation/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Introduction to Queue Data Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-queue-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Basic Terminologies of Queue",
            "content": "Front: Position of the entry in a queue ready to be served, that is, the first entry that will be removed from the queue, is called the front of the queue. It is also referred as the head of the queue.\nRear: Position of the last entry in the queue, that is, the one most recently added, is called the rear of the queue. It is also referred as the tail of the queue.\nSize: Size refers to the current number of elements in the queue.\nCapacity: Capacity refers to the maximum number of elements the queue can hold.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Queue",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Queue Operations",
            "content": "Enqueue: Adds an element to the end (rear) of the queue. If the queue is full, an overflow error occurs.\nDequeue: Removes the element from the front of the queue. If the queue is empty, an underflow error occurs.\nPeek/Front: Returns the element at the front without removing it.\nSize: Returns the number of elements in the queue.\nisEmpty: Returns true if the queue is empty, otherwise false.\nisFull: Returns true if the queue is full, otherwise false.\nFor detailed steps and more information on each operation, Read Basic Operations for Queue in Data Structure.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of Queue Data Structure",
            "content": "Queue can be implemented using following data structures:\nSimple Array implementation of Queue\nEfficient Array Implementation of Queue\nImplementation of Queue using Linked List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Complexity Analysis of Operations on Queue",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Queues",
            "content": "Queue data structure can be classified into 4 types:\nSimple Queue: Simple Queue simply follows FIFO Structure. We can only insert the element at the back and remove the element from the front of the queue. A simple queue is efficiently implemented either using a linked list or a circular array.\nDouble-Ended Queue (Deque): In a double-ended queue the insertion and deletion operations, both can be performed from both ends. They are of two types:\nInput Restricted Queue: This is a simple queue. In this type of queue, the input can be taken from only one end but deletion can be done from any of the ends.\nOutput Restricted Queue: This is also a simple queue. In this type of queue, the input can be taken from both ends but deletion can be done from only one end.\nPriority Queue: A priority queue is a special queue where the elements are accessed based on the priority assigned to them. They are of two types:\nAscending Priority Queue: In Ascending Priority Queue, the elements are arranged in increasing order of their priority values. Element with smallest priority value is popped first.\nDescending Priority Queue: In Descending Priority Queue, the elements are arranged in decreasing order of their priority values. Element with largest priority is popped first.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Queue Data Structure",
            "content": "Application of queue is common. In a computer system, there may be queues of tasks waiting for the printer, for access to disk storage, or even in a time-sharing system, for use of the CPU. Within a single program, there may be multiple requests to be kept in a queue, or one task may create other tasks, which must be done in turn by keeping them in a queue.\nA Queue is always used as a buffer when we have a speed mismatch between a producer and consumer. For example keyboard and CPU.\nQueue can be used where we have a single resource and multiple consumers like a single CPU and multiple processes.\nIn a network, a queue is used in devices such as a router/switch and mail queue.\nQueue can be used in various algorithm techniques like Breadth First Search, Topological Sort, etc.\nPlease refer Applications of Queue for more details.\nQueue Operations \nApplications, Advantages and Disadvantages of Queue\nMaximum of all subarrays of size k\nGenerate Binary Numbers\nQueue using two Stacks\nReverse First K elements of Queue\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "16. Deque",
    "main_article_link": "https://www.geeksforgeeks.org/deque-set-1-introduction-applications/",
    "subtopics": [
      {
        "subtopic_title": "Implementation of Deque using circular array",
        "subtopic_url": "https://www.geeksforgeeks.org/implementation-deque-using-circular-array/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Circular array implementation of Deque",
            "content": "For implementing deque, we need to keep track of two indices, front and rear. We enqueue(push) an item at the rear or the front end of the deque and dequeue(pop) an item from both the rear and the front end.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Working:",
            "content": "Create an array ‘arr' of size n to store the elements. \nInitialize the front and size: front is initialized to 0, and size to 0, indicating the deque is initially empty.\nInserting elements: When an element is inserted at the front, we move the front index circularly. Similarly, inserting at the rear calculates the rear index using the formula (front + size) % capacity.\nRemoving elements: Deleting from the front decreases the front index, and deleting from the rear calculates the rear index using (front + size - 1) % capacity to remove elements accordingly.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Insert Elements at the Rear end",
            "content": "First we check deque if Full or Not\nIf size == capacity\nreturn (deque is full)\nElse calculate rear index: rear = (front + size) % capacity\nInsert element into arr[rear] = key\nIncrement size by 1\nsize++\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Insert Elements at the Front end  of Deque:",
            "content": "First we check deque if Full or Not\nIF size == capacity\nreturn (deque is full)\nElse calculate front index: front = (front - 1 + capacity) % capacity\nInsert element into arr[front] = key\nIncrement size by 1 \nsize++\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Delete Element From Rear end of Deque",
            "content": "First we check deque if Empty or Not\nIF size == 0\nreturn (deque is empty)\nElse calculate rear index: rear = (front + size - 1) % capacity\nStore the element to be deleted: res = arr[rear]\nDecrement size by 1\nsize--\nReturn the deleted element\nreturn res\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Delete Element From the Front end of Deque",
            "content": "First we check deque if Empty or Not\nIF size == 0\nreturn (deque is empty)\nStore the front element: res = arr[front]\nMove front index circularly: front = (front + 1) % capacity\nDecrement size by 1\nsize--\nReturn the deleted element\nreturn res\nBelow is the implementation of the above methods:\nTime Complexity:\ninsertFront(x): O(1)\ninsertRear(x): O(1)\ndeleteFront(): O(1)\ndeleteRear(): O(1)\nfrontEle(): O(1)\nrearEle(): O(1)\nAuxiliary Space: O(n), where n is the size of the array for storing elements.\n",
            "code_snippets": {
              "cpp": "// C++ implementation of De-queue using circular array#include <iostream>using namespace std;class MyDeque {  private:    int *arr;    int front, size, capacity;  public:    // Constructor to initialize the deque    MyDeque(int c) {        arr = new int[c];        capacity = c;        size = 0;        front = 0;    }    // Delete element from the front    int deleteFront() {        // Empty deque        if (size == 0)            return -1;        int res = arr[front];        // Move front index circularly        front = (front + 1) % capacity;        size--;        return res;    }    // Insert element at the front    void insertFront(int x) {        // Full deque        if (size == capacity)            return;        // Move front index circularly        front = (front - 1 + capacity) % capacity;        arr[front] = x;        size++;    }    // Insert element at the rear    void insertRear(int x) {        // Full deque        if (size == capacity)            return;        // Calculate rear index        int rear = (front + size) % capacity;        arr[rear] = x;        size++;    }    // Delete element from the rear    int deleteRear() {        // Empty deque        if (size == 0)            return -1;        int rear = (front + size - 1) % capacity;        size--;        return arr[rear];    }    // Get the front element    int frontEle() {        return arr[front];    }    // Get the rear element    int rearEle() {        // Calculate rear index        int rear = (front + size - 1) % capacity;        return arr[rear];    }};int main() {    // Create deque with capacity 4    MyDeque dq(4);    // Insert at rear    dq.insertRear(10);    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    // Insert at front    dq.insertFront(20);    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    dq.insertFront(30);    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    // Delete from rear    dq.deleteRear();    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    dq.insertRear(40);    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    dq.deleteRear();    cout << dq.frontEle() << \" \" << dq.rearEle() << endl;    return 0;}",
              "java": "// Java implementation of De-queue using circular arrayclassMyDeque {    private int[] arr;    private int front, size, capacity;    // Constructor to initialize the deque with a given    // capacity    public MyDeque(int c) {        arr = new int[c];        capacity = c;        size = 0;        front = 0;    }    // Delete element from the front    public int deleteFront() {        // Empty deque        if (size == 0)            return -1;        int res = arr[front];        // Move front index circularly        front = (front + 1) % capacity;        size--;        return res;    }    // Insert element at the front    public void insertFront(int x) {        // Full deque        if (size == capacity)            return;        // Move front index circularly        front = (front - 1 + capacity) % capacity;        arr[front] = x;        size++;    }    // Insert element at the rear    public void insertRear(int x) {        // Full deque        if (size == capacity)            return;        // Calculate rear index        int rear = (front + size) % capacity;        arr[rear] = x;        size++;    }    // Delete element from the rear    public int deleteRear() {        // Empty deque        if (size == 0)            return -1;        // Calculate rear index        int rear = (front + size - 1) % capacity;        size--;        return arr[rear];    }    // Get the front element    public int frontEle() { return arr[front]; }    // Get the rear element    public int rearEle() {        // Calculate rear index        int rear = (front + size - 1) % capacity;        return arr[rear];    }}classGfG {    public static void main(String[] args) {        // Create deque with capacity 4        MyDeque dq = new MyDeque(4);        // Insert at rear        dq.insertRear(10);        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());        // Insert at front        dq.insertFront(20);        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());        dq.insertFront(30);        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());        // Delete from rear        dq.deleteRear();        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());        dq.insertRear(40);        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());        dq.deleteRear();        System.out.println(dq.frontEle() + \" \"                           + dq.rearEle());    }}",
              "python3": "# Python implementation of De-queue using circular arrayclassMyDeque:# Constructor to initialize the deque with a given capacitydef__init__(self,c):self.l=[None]*cself.cap=cself.size=0self.front=0# Delete element from the frontdefdeleteFront(self):# Return None if deque is emptyifself.size==0:returnNoneelse:res=self.l[self.front]# Move front index circularlyself.front=(self.front+1)%self.capself.size-=1returnres# Insert element at the frontdefinsertFront(self,x):# Return if deque is fullifself.size==self.cap:returnelse:# Move front index circularlyself.front=(self.front-1+self.cap)%self.capself.l[self.front]=xself.size+=1# Insert element at the reardefinsertRear(self,x):# Return if deque is fullifself.size==self.cap:return# Calculate rear indexnew_rear=(self.front+self.size)%self.capself.l[new_rear]=xself.size+=1# Delete element from the reardefdeleteRear(self):sz=self.size# Return None if deque is emptyifsz==0:returnNoneelse:# Calculate rear indexrear=(self.front+sz-1)%self.capself.size-=1returnself.l[rear]# Get the front elementdeffrontEle(self):returnself.l[self.front]# Get the rear elementdefrearEle(self):# Calculate rear indexrear=(self.front+self.size-1)%self.capreturnself.l[rear]if__name__==\"__main__\":# Create deque with capacity 4dq=MyDeque(4)# Insert at reardq.insertRear(10)print(dq.frontEle(),dq.rearEle())# Insert at frontdq.insertFront(20)print(dq.frontEle(),dq.rearEle())dq.insertFront(30)print(dq.frontEle(),dq.rearEle())# Delete from reardq.deleteRear()print(dq.frontEle(),dq.rearEle())dq.insertRear(40)print(dq.frontEle(),dq.rearEle())dq.deleteRear()print(dq.frontEle(),dq.rearEle())",
              "csharp": "// C# implementation of De-queue using circular arrayusing System;class MyDeque {    private int[] arr;    private int front, size, capacity;    // Constructor to initialize the deque with a given    // capacity    public MyDeque(int c) {        arr = new int[c];        capacity = c;        size = 0;        front = 0;    }    // Delete element from the front    public int deleteFront() {        // Empty deque        if (size == 0)            return -1;        int res = arr[front];        // Move front index circularly        front = (front + 1) % capacity;        size--;        return res;    }    // Insert element at the front    public void insertFront(int x) {        // Full deque        if (size == capacity)            return;        // Move front index circularly        front = (front - 1 + capacity) % capacity;        arr[front] = x;        size++;    }    // Insert element at the rear    public void insertRear(int x) {        // Full deque        if (size == capacity)            return;        // Calculate rear index        int rear = (front + size) % capacity;        arr[rear] = x;        size++;    }    // Delete element from the rear    public int deleteRear() {        // Empty deque        if (size == 0)            return -1;        // Calculate rear index        int rear = (front + size - 1) % capacity;        size--;        return arr[rear];    }    // Get the front element    public int frontEle() { return arr[front]; }    // Get the rear element    public int rearEle() {        int rear = (front + size - 1) % capacity;        return arr[rear];    }}class GfG {    static void Main() {        // Create deque with capacity 4        MyDeque dq = new MyDeque(4);        // Insert at rear        dq.insertRear(10);        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());        // Insert at front        dq.insertFront(20);        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());        dq.insertFront(30);        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());        // Delete from rear        dq.deleteRear();        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());        dq.insertRear(40);        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());        dq.deleteRear();        Console.WriteLine(dq.frontEle() + \" \"                          + dq.rearEle());    }}",
              "javascript": "// Javascript implementation of De-queue using circular// arrayclass MyDeque {    constructor(c) {        this.arr = new Array(c);        this.capacity = c;        this.size = 0;        this.front = 0;    }    // Delete element from the front    deleteFront() {        // Empty deque        if (this.size === 0)            return -1;        const res = this.arr[this.front];        // Move front index circularly        this.front = (this.front + 1) % this.capacity;        this.size--;        return res;    }    // Insert element at the front    insertFront(x) {        // Full deque        if (this.size === this.capacity)            return;        // Move front index circularly        this.front = (this.front - 1 + this.capacity)                     % this.capacity;        this.arr[this.front] = x;        this.size++;    }    // Insert element at the rear    insertRear(x) {        // Full deque        if (this.size === this.capacity)            return;        // Calculate rear index        const rear            = (this.front + this.size) % this.capacity;        this.arr[rear] = x;        this.size++;    }    // Delete element from the rear    deleteRear() {        // Empty deque        if (this.size === 0)            return -1;        // Calculate rear index        const rear            = (this.front + this.size - 1) % this.capacity;        this.size--; // Decrease size        return this.arr[rear];    }    // Get the front element    frontEle() { return this.arr[this.front]; }    // Get the rear element    rearEle() {        const rear            = (this.front + this.size - 1) % this.capacity;        return this.arr[rear];    }}// Test case// Create deque with capacity 4const dq = new MyDeque(4);// Insert at reardq.insertRear(10);console.log(dq.frontEle(), dq.rearEle());// Insert at frontdq.insertFront(20);console.log(dq.frontEle(), dq.rearEle());dq.insertFront(30);console.log(dq.frontEle(), dq.rearEle());// Delete from reardq.deleteRear();console.log(dq.frontEle(), dq.rearEle());dq.insertRear(40);console.log(dq.frontEle(), dq.rearEle());dq.deleteRear();console.log(dq.frontEle(), dq.rearEle());"
            }
          }
        ]
      },
      {
        "subtopic_title": "Implementation of Deque using doubly linked list",
        "subtopic_url": "https://www.geeksforgeeks.org/implementation-deque-using-doubly-linked-list/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Operations on Deque",
            "content": "The following four basic operations are typically performed on a deque:\ninsertFront(): Adds an item at the front of the deque.\ninsertRear(): Adds an item at the rear of the deque.\ndeleteFront(): Removes an item from the front of the deque.\ndeleteRear(): Removes an item from the rear of the deque.\nAdditionally, the following operations are also supported:\ngetFront(): Retrieves the front item from the deque.\ngetRear(): Retrieves the last item from the deque.\nisEmpty(): Checks if the deque is empty.\nsize(): Returns the number of elements in the deque.\nerase(): Removes all elements from the deque.\nDoubly Linked List Representation of Deque\nFor implementing deque, we need to keep track of two pointers, front and rear. We enqueue (push) an item at the rear or the front end of deque and dequeue(pop) an item from both rear and front end.\nWorking\nDeclare two pointers front and rear of type Node, where Node represents the structure of a node of a doubly linked list. Initialize both of them with value NULL.\nInsertion at Front end\n1. Allocate space for a newNode of doubly linked list.\n2. IF newNode == NULL, then\n3.     print \"Overflow\"\n4. ELSE\n5.     IF front == NULL, then\n6.          rear = front = newNode\n7.     ELSE\n8.         newNode->next = front\n9.        front->prev = newNode\n10.       front = newNode\nInsertion at Rear end\n1. Allocate space for a newNode of doubly linked list.\n2. IF newNode == NULL, then\n3.     print \"Overflow\"\n4. ELSE\n5.     IF rear == NULL, then\n6.         front = rear = newNode\n7.     ELSE\n8.         newNode->prev = rear\n9.       rear->next = newNode\n10.        rear = newNode\nDeletion from Front end\n1. IF front == NULL\n2.     print \"Underflow\"\n3. ELSE\n4.     Initialize temp = front\n5.     front = front->next\n6.     IF front == NULL\n7.         rear = NULL\n8.     ELSE\n9.         front->prev = NULL\n10     Deallocate space for temp\nDeletion from Rear end\n1. IF front == NULL\n2.     print \"Underflow\"\n3. ELSE\n4.     Initialize temp = rear\n5.     rear = rear->prev\n6.     IF rear == NULL\n7.         front = NULL\n8.     ELSE\n9.         rear->next = NULL\n10     Deallocate space for temp\nTime Complexity : Time complexity of operations like insertFront(), insertRear(), deleteFront(), deleteRear() is O(1). The Time Complexity of erase() is O(n).\nAuxiliary space: O(1)\n",
            "code_snippets": {
              "cpp": "#include <iostream>using namespace std;struct Node {    int data;    Node *prev, *next;    Node(int data) {         this->data = data;         prev = nullptr;         next = nullptr;     }};class Deque {    Node *front, *rear;    int size;public:    Deque() { front = nullptr; rear = nullptr; size = 0; }    bool isEmpty() { return front == nullptr; }    int getSize() { return size; }    void insertFront(int data) {        Node* newNode = new Node(data);        if (isEmpty()) front = rear = newNode;        else {            newNode->next = front;            front->prev = newNode;            front = newNode;        }        size++;    }    void insertRear(int data) {        Node* newNode = new Node(data);        if (isEmpty()) front = rear = newNode;        else {            newNode->prev = rear;            rear->next = newNode;            rear = newNode;        }        size++;    }    void deleteFront() {        if (isEmpty()) cout << \"UnderFlow\\n\";        else {            Node* temp = front;            front = front->next;            if (front) front->prev = nullptr;            else rear = nullptr;            delete temp;            size--;        }    }    void deleteRear() {        if (isEmpty()) cout << \"UnderFlow\\n\";        else {            Node* temp = rear;            rear = rear->prev;            if (rear) rear->next = nullptr;            else front = nullptr;            delete temp;            size--;        }    }    int getFront() { return isEmpty() ? -1 : front->data; }    int getRear() { return isEmpty() ? -1 : rear->data; }    void clear() {        while (!isEmpty()) deleteFront();    }};int main() {    Deque dq;    dq.insertRear(5);    dq.insertRear(10);    cout << \"Rear: \" << dq.getRear() << endl;    dq.deleteRear();    cout << \"New Rear: \" << dq.getRear() << endl;    dq.insertFront(15);    cout << \"Front: \" << dq.getFront() << endl;    cout << \"Size: \" << dq.getSize() << endl;    dq.deleteFront();    cout << \"New Front: \" << dq.getFront() << endl;    return 0;}",
              "c": "#include <stdio.h>#include <stdlib.h>struct Node {    int data;    struct Node *prev, *next;};struct Deque {    struct Node *front, *rear;    int size;};struct Deque* createDeque() {    struct Deque* dq = (struct Deque*)malloc(sizeof(struct Deque));    dq->front = dq->rear = NULL;    dq->size = 0;    return dq;}int isEmpty(struct Deque* dq) { return dq->front == NULL; }int getSize(struct Deque* dq) { return dq->size; }void insertFront(struct Deque* dq, int data) {    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));    newNode->data = data;    newNode->prev = NULL;    newNode->next = dq->front;    if (isEmpty(dq)) dq->front = dq->rear = newNode;    else {        dq->front->prev = newNode;        dq->front = newNode;    }    dq->size++;}void insertRear(struct Deque* dq, int data) {    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));    newNode->data = data;    newNode->next = NULL;    if (isEmpty(dq)) dq->front = dq->rear = newNode;    else {        newNode->prev = dq->rear;        dq->rear->next = newNode;        dq->rear = newNode;    }    dq->size++;}void deleteFront(struct Deque* dq) {    if (isEmpty(dq)) printf(\"UnderFlow\\n\");    else {        struct Node* temp = dq->front;        dq->front = dq->front->next;        if (dq->front) dq->front->prev = NULL;        else dq->rear = NULL;        free(temp);        dq->size--;    }}void deleteRear(struct Deque* dq) {    if (isEmpty(dq)) printf(\"UnderFlow\\n\");    else {        struct Node* temp = dq->rear;        dq->rear = dq->rear->prev;        if (dq->rear) dq->rear->next = NULL;        else dq->front = NULL;        free(temp);        dq->size--;    }}int getFront(struct Deque* dq) { return isEmpty(dq) ? -1 : dq->front->data; }int getRear(struct Deque* dq) { return isEmpty(dq) ? -1 : dq->rear->data; }void clear(struct Deque* dq) {    while (!isEmpty(dq)) deleteFront(dq);}int main() {    struct Deque* dq = createDeque();    insertRear(dq, 5);    insertRear(dq, 10);    printf(\"Rear: %d\\n\", getRear(dq));    deleteRear(dq);    printf(\"New Rear: %d\\n\", getRear(dq));    insertFront(dq, 15);    printf(\"Front: %d\\n\", getFront(dq));    printf(\"Size: %d\\n\", getSize(dq));    deleteFront(dq);    printf(\"New Front: %d\\n\", getFront(dq));    clear(dq);    free(dq);    return 0;}",
              "java": "import java.util.LinkedList;import java.util.Deque;public classDequeExample {    private LinkedList<Integer> deque;    public DequeExample() {        deque = new LinkedList<>();    }    public boolean isEmpty() { return deque.isEmpty(); }    public int getSize() { return deque.size(); }    public void insertFront(int data) {        deque.addFirst(data);    }    public void insertRear(int data) {        deque.addLast(data);    }    public void deleteFront() {        if (isEmpty()) System.out.println(\"UnderFlow\");        else deque.removeFirst();    }    public void deleteRear() {        if (isEmpty()) System.out.println(\"UnderFlow\");        else deque.removeLast();    }    public int getFront() { return isEmpty() ? -1 : deque.getFirst(); }    public int getRear() { return isEmpty() ? -1 : deque.getLast(); }    public void clear() { deque.clear(); }    public static void main(String[] args) {        DequeExample dq = new DequeExample();        dq.insertRear(5);        dq.insertRear(10);        System.out.println(\"Rear: \" + dq.getRear());        dq.deleteRear();        System.out.println(\"New Rear: \" + dq.getRear());        dq.insertFront(15);        System.out.println(\"Front: \" + dq.getFront());        System.out.println(\"Size: \" + dq.getSize());        dq.deleteFront();        System.out.println(\"New Front: \" + dq.getFront());    }}",
              "python3": "# Deque implementation in PythonclassNode:def__init__(self,data):self.data=dataself.prev=Noneself.next=NoneclassDeque:def__init__(self):self.front=Noneself.rear=Noneself.size=0defis_empty(self):returnself.frontisNonedefget_size(self):returnself.sizedefinsert_front(self,data):new_node=Node(data)ifself.is_empty():self.front=self.rear=new_nodeelse:new_node.next=self.frontself.front.prev=new_nodeself.front=new_nodeself.size+=1definsert_rear(self,data):new_node=Node(data)ifself.is_empty():self.front=self.rear=new_nodeelse:new_node.prev=self.rearself.rear.next=new_nodeself.rear=new_nodeself.size+=1defdelete_front(self):ifself.is_empty():print(\"UnderFlow\")else:temp=self.frontself.front=self.front.nextifself.front:self.front.prev=Noneelse:self.rear=Nonedeltempself.size-=1defdelete_rear(self):ifself.is_empty():print(\"UnderFlow\")else:temp=self.rearself.rear=self.rear.previfself.rear:self.rear.next=Noneelse:self.front=Nonedeltempself.size-=1defget_front(self):return-1ifself.is_empty()elseself.front.datadefget_rear(self):return-1ifself.is_empty()elseself.rear.datadefclear(self):whilenotself.is_empty():self.delete_front()# Example usageif__name__=='__main__':dq=Deque()dq.insert_rear(5)dq.insert_rear(10)print(\"Rear:\",dq.get_rear())dq.delete_rear()print(\"New Rear:\",dq.get_rear())dq.insert_front(15)print(\"Front:\",dq.get_front())print(\"Size:\",dq.get_size())dq.delete_front()print(\"New Front:\",dq.get_front())",
              "csharp": "// Deque implementation in C#using System;public class Node {    public int data;    public Node prev, next;    public Node(int data) {        this.data = data;        this.prev = null;        this.next = null;    }}public class Deque {    private Node front, rear;    private int size;    public Deque() {        front = rear = null;        size = 0;    }    public bool IsEmpty() {        return front == null;    }    public int GetSize() {        return size;    }    public void InsertFront(int data) {        Node newNode = new Node(data);        if (IsEmpty()) front = rear = newNode;        else {            newNode.next = front;            front.prev = newNode;            front = newNode;        }        size++;    }    public void InsertRear(int data) {        Node newNode = new Node(data);        if (IsEmpty()) front = rear = newNode;        else {            newNode.prev = rear;            rear.next = newNode;            rear = newNode;        }        size++;    }    public void DeleteFront() {        if (IsEmpty()) Console.WriteLine(\"UnderFlow\");        else {            Node temp = front;            front = front.next;            if (front != null) front.prev = null;            else rear = null;            temp = null;            size--;        }    }    public void DeleteRear() {        if (IsEmpty()) Console.WriteLine(\"UnderFlow\");        else {            Node temp = rear;            rear = rear.prev;            if (rear != null) rear.next = null;            else front = null;            temp = null;            size--;        }    }    public int GetFront() {        return IsEmpty() ? -1 : front.data;    }    public int GetRear() {        return IsEmpty() ? -1 : rear.data;    }    public void Clear() {        while (!IsEmpty()) DeleteFront();    }}class Program {    static void Main() {        Deque dq = new Deque();        dq.InsertRear(5);        dq.InsertRear(10);        Console.WriteLine(\"Rear: \" + dq.GetRear());        dq.DeleteRear();        Console.WriteLine(\"New Rear: \" + dq.GetRear());        dq.InsertFront(15);        Console.WriteLine(\"Front: \" + dq.GetFront());        Console.WriteLine(\"Size: \" + dq.GetSize());        dq.DeleteFront();        Console.WriteLine(\"New Front: \" + dq.GetFront());    }}",
              "javascript": "class Node {    constructor(data) {        this.data = data;        this.prev = null;        this.next = null;    }}class Deque {    constructor() {        this.front = null;        this.rear = null;        this.size = 0;    }    isEmpty() {        return this.front === null;    }    getSize() {        return this.size;    }    insertFront(data) {        const newNode = new Node(data);        if (this.isEmpty()) {            this.front = this.rear = newNode;        } else {            newNode.next = this.front;            this.front.prev = newNode;            this.front = newNode;        }        this.size++;    }    insertRear(data) {        const newNode = new Node(data);        if (this.isEmpty()) {            this.front = this.rear = newNode;        } else {            newNode.prev = this.rear;            this.rear.next = newNode;            this.rear = newNode;        }        this.size++;    }    deleteFront() {        if (this.isEmpty()) console.log(\"UnderFlow\");        else {            const temp = this.front;            this.front = this.front.next;            if (this.front) this.front.prev = null;            else this.rear = null;            this.size--;        }    }    deleteRear() {        if (this.isEmpty()) console.log(\"UnderFlow\");        else {            const temp = this.rear;            this.rear = this.rear.prev;            if (this.rear) this.rear.next = null;            else this.front = null;            this.size--;        }    }    getFront() {        return this.isEmpty() ? -1 : this.front.data;    }    getRear() {        return this.isEmpty() ? -1 : this.rear.data;    }    clear() {        while (!this.isEmpty()) this.deleteFront();    }}// Driver codeconst dq = new Deque();dq.insertRear(5);dq.insertRear(10);console.log(\"Rear:\", dq.getRear());dq.deleteRear();console.log(\"New Rear:\", dq.getRear());dq.insertFront(15);console.log(\"Front:\", dq.getFront());console.log(\"Size:\", dq.getSize());dq.deleteFront();console.log(\"New Front:\", dq.getFront());"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "17. Tree",
    "main_article_link": "https://www.geeksforgeeks.org/tree-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Types of Trees in Data Structures",
        "subtopic_url": "https://www.geeksforgeeks.org/types-of-trees-in-data-structures/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Types of Trees",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "The main types of trees in data structure are:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Binary Tree",
            "content": "A binary tree is a tree data structure where each node has at most two children. These two children are usually referred to as the left child and right child. It is widely used in applications such as binary search trees and heaps.\nExample: Consider the tree below. Since each node of this tree has only 2 children, it can be said that this tree is a Binary Tree\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Examples / Types of Binary Tree:",
            "content": "Complete Binary Tree: A binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. For example, a heap is a complete binary tree that satisfies the heap property (either max-heap or min-heap).\nFull Binary Tree: A binary tree where every node has either 0 or 2 children.\nDegenerate Binary Tree (or Pathological Tree): A tree in which each parent node has only one child. This essentially forms a linked list, which leads to inefficient operations.\nBinary Search Tree (BST) and its Variations: A BST is a binary tree where each node has at most two children, and for each node, the left child’s value is smaller than the node’s value, and the right child’s value is greater. An AVL Tree is a self-balancing BST where the heights of the two child subtrees of any node differ by no more than one. Red Black Tree and Splay Tree are more example variations of BST.\nBinary Indexed Tree (Fenwick Tree): A data structure that uses a binary tree to efficiently compute and update prefix sums in an array.\nPerfect Binary Tree: A binary tree where all internal nodes have two children and all leaf nodes are at the same level.\nBalanced Binary Tree: A binary tree where the difference in heights between the left and right subtrees of any node is minimal (often defined as at most 1). Examples of Balanced Binary Tree are AVL Tree, Red Black Tree and Splay Tree\nSegment Tree: A segment tree is a binary tree used for storing intervals or segments. It allows efficient querying and updating of ranges of values, making it particularly useful for problems that involve finding the sum, minimum, maximum, or other operations over a range of elements in an array.\nTo know more about the types of the binary trees, please refer to this detailed article: Types of Binary Tree.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Ternary Tree",
            "content": "A Ternary Tree is a tree data structure in which each node has at most three child nodes, usually distinguished as “left”, “mid” and “right”.\nExample: Consider the tree below. Since each node of this tree has only 3 children, it can be said that this tree is a Ternary Tree.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Examples of Ternary Tree:",
            "content": "Ternary Search Tree: A ternary search tree is a special trie data structure where the child nodes of a standard trie are ordered as a binary search tree.\nTernary Heap: A type of heap where each node can have up to three children, though less common than binary heaps.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. N-ary Tree (Generic Tree)",
            "content": "Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes.\nEvery node stores the addresses of its children and the very first node’s address will be stored in a separate pointer called root.\n1. Many children at every node.\n 2. The number of nodes for each node is not known in advance.\nExample:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Examples of N-ary Trees:",
            "content": "B-tree: A self-balancing search tree where nodes can have multiple children, usually used for indexing large databases.\nB+ Tree: A B+ tree is a variation of the B-tree that only stores data in the leaf nodes, making range queries more efficient.\nTrie (Prefix Tree): A tree where each node represents a character, and paths from the root to leaves represent strings. It can have a variable number of children for each node, making it an N-ary tree.\n",
            "code_snippets": {}
          }
        ]
      },
      {
        "subtopic_title": "Introduction to Tree Data Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Basic Terminologies In Tree Data Structure:",
            "content": "Parent Node: The node which is an immediate predecessor of a node is called the parent node of that node. {B} is the parent node of {D, E}.\nChild Node: The node which is the immediate successor of a node is called the child node of that node. Examples: {D, E} are the child nodes of {B}.\nRoot Node: The topmost node of a tree or the node which does not have any parent node is called the root node. {A} is the root node of the tree. A non-empty tree must contain exactly one root node and exactly one path from the root to all other nodes of the tree.\nLeaf Node or External Node: The nodes which do not have any child nodes are called leaf nodes. {I, J, K, F, G, H} are the leaf nodes of the tree.\nAncestor of a Node: Any predecessor nodes on the path of the root to that node are called Ancestors of that node. {A,B} are the ancestor nodes of the node {E}\nDescendant: A node x is a descendant of another node y if and only if y is an ancestor of x.\nSibling: Children of the same parent node are called siblings. {D,E} are called siblings.\nLevel of a node: The count of edges on the path from the root node to that node. The root node has level 0.\nInternal node: A node with at least one child is called Internal Node.\nNeighbour of a Node: Parent or child nodes of that node are called neighbors of that node.\nSubtree: Any node of the tree along with its descendant.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why Tree is considered a non-linear data structure?",
            "content": "The data in a tree are not stored in a sequential manner i.e., they are not stored linearly. Instead, they are arranged on multiple levels or we can say it is a hierarchical structure. For this reason, the tree is considered to be a non-linear data structure.\nWe strongly recommend to study a Binary Tree first as a Binary Tree has structure and code implementation compared to a general tree.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Tree Data Structure:",
            "content": "A tree consists of a root node, and zero or more subtrees T1, T2, ... , Tk such that there is an edge from the root node of the tree to the root node of each subtree. Subtree of a node X consists of all the nodes which have node X as the ancestor node.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of a Node in Tree Data Structure:",
            "content": "A tree can be represented using a collection of nodes. Each of the nodes can be represented with the help of class or structs. Below is the representation of Node in different languages:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Importance for Tree Data Structure:",
            "content": "One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: The DOM model of an HTML page is also tree where we have html tag as root, head and body its children and these tags, then have their own children.Please refer Applications, Advantages and Disadvantages of Tree for details.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Tree data structures:",
            "content": "Tree data structure can be classified into three types based upon the number of children each node of the tree can have. The types are:\nBinary tree: In a binary tree, each node can have a maximum of two children linked to it. Some common types of binary trees include full binary trees, complete binary trees, balanced binary trees, and degenerate or pathological binary trees. Examples of Binary Tree are Binary Search Tree and Binary Heap.\nTernary Tree: A Ternary Tree is a tree data structure in which each node has at most three child nodes, usually distinguished as “left”, “mid” and “right”.\nN-ary Tree or Generic Tree: Generic trees are a collection of nodes where each node is a data structure that consists of records and a list of references to its children(duplicate references are not allowed). Unlike the linked list, each node stores the address of multiple nodes.\nPlease refer Types of Trees in Data Structures for details.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Basic Operations Of Tree Data Structure:",
            "content": "Create – create a tree in the data structure.\nInsert − Inserts data in a tree.\nSearch − Searches specific data in a tree to check whether it is present or not.\nTraversal:\nDepth-First-Search Traversal\nBreadth-First-Search Traversal\nImplementation of Tree Data Structure:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Properties of Tree Data Structure:",
            "content": "Number of edges: An edge can be defined as the connection between two nodes. If a tree has N nodes then it will have (N-1) edges. There is only one path from each node to any other node of the tree.\nDepth of a node: The depth of a node is defined as the length of the path from the root to that node. Each edge adds 1 unit of length to the path. So, it can also be defined as the number of edges in the path from the root of the tree to the node.\nHeight of a node: The height of a node can be defined as the length of the longest path from the node to a leaf node of the tree.\nHeight of the Tree: The height of a tree is the length of the longest path from the root of the tree to a leaf node of the tree.\nDegree of a Node: The total count of subtrees attached to that node is called the degree of the node. The degree of a leaf node must be 0. The degree of a tree is the maximum degree of a node among all the nodes in the tree.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Easy Problem On Tree in JavaScript",
            "content": "Inorder Traversal of Binary Tree\nPreorder Traversal of Binary Tree\nPostorder Traversal of Binary Tree\nLevel Order Tree Traversal\nHeight or Depth of a Binary Tree\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Medium Problem On Tree in JavaScript",
            "content": "Connect nodes at same level\nNodes at given distance in a Binary Tree\nBinary Tree to Doubly Linked List\nMaximum sum path between two leaf\nK-Sum Paths\nBoundary Traversal\n",
            "code_snippets": {
              "cpp": "// C++ program to demonstrate some of the above// terminologies#include <bits/stdc++.h>using namespace std;// Function to add an edge between vertices x and yvoid addEdge(int x, int y, vector<vector<int> >& adj){    adj[x].push_back(y);    adj[y].push_back(x);}// Function to print the parent of each nodevoid printParents(int node, vector<vector<int> >& adj,                  int parent){    // current node is Root, thus, has no parent    if (parent == 0)        cout << node << \"->Root\" << endl;    else        cout << node << \"->\" << parent << endl;      // Using DFS    for (auto cur : adj[node])        if (cur != parent)            printParents(cur, adj, node);}// Function to print the children of each nodevoid printChildren(int Root, vector<vector<int> >& adj){    // Queue for the BFS    queue<int> q;      // pushing the root    q.push(Root);      // visit array to keep track of nodes that have been    // visited    int vis[adj.size()] = { 0 };      // BFS    while (!q.empty()) {        int node = q.front();        q.pop();        vis[node] = 1;        cout << node << \"-> \";        for (auto cur : adj[node])            if (vis[cur] == 0) {                cout << cur << \" \";                q.push(cur);            }        cout << endl;    }}// Function to print the leaf nodesvoid printLeafNodes(int Root, vector<vector<int> >& adj){    // Leaf nodes have only one edge and are not the root    for (int i = 1; i < adj.size(); i++)        if (adj[i].size() == 1 && i != Root)            cout << i << \" \";    cout << endl;}// Function to print the degrees of each nodevoid printDegrees(int Root, vector<vector<int> >& adj){    for (int i = 1; i < adj.size(); i++) {        cout << i << \": \";              // Root has no parent, thus, its degree is equal to        // the edges it is connected to        if (i == Root)            cout << adj[i].size() << endl;        else            cout << adj[i].size() - 1 << endl;    }}// Driver codeint main(){    // Number of nodes    int N = 7, Root = 1;    // Adjacency list to store the tree    vector<vector<int> > adj(N + 1, vector<int>());    // Creating the tree    addEdge(1, 2, adj);    addEdge(1, 3, adj);    addEdge(1, 4, adj);    addEdge(2, 5, adj);    addEdge(2, 6, adj);    addEdge(4, 7, adj);      // Printing the parents of each node    cout << \"The parents of each node are:\" << endl;    printParents(Root, adj, 0);    // Printing the children of each node    cout << \"The children of each node are:\" << endl;    printChildren(Root, adj);    // Printing the leaf nodes in the tree    cout << \"The leaf nodes of the tree are:\" << endl;    printLeafNodes(Root, adj);    // Printing the degrees of each node    cout << \"The degrees of each node are:\" << endl;    printDegrees(Root, adj);    return 0;}",
              "c": "struct Node {    int data;    struct Node* first_child;    struct Node* second_child;    struct Node* third_child;    .    .    .    struct Node* nth_child;};",
              "java": "// java code for above approachimport java.io.*;import java.util.*;classGFG {    // Function to print the parent of each node    public static void    printParents(int node, Vector<Vector<Integer> > adj,                 int parent)    {        // current node is Root, thus, has no parent        if (parent == 0)            System.out.println(node + \"->Root\");        else            System.out.println(node + \"->\" + parent);        // Using DFS        for (int i = 0; i < adj.get(node).size(); i++)            if (adj.get(node).get(i) != parent)                printParents(adj.get(node).get(i), adj,                             node);    }    // Function to print the children of each node    public static void    printChildren(int Root, Vector<Vector<Integer> > adj)    {        // Queue for the BFS        Queue<Integer> q = new LinkedList<>();        // pushing the root        q.add(Root);        // visit array to keep track of nodes that have been        // visited        int vis[] = new int[adj.size()];        Arrays.fill(vis, 0);        // BFS        while (q.size() != 0) {            int node = q.peek();            q.remove();            vis[node] = 1;            System.out.print(node + \"-> \");            for (int i = 0; i < adj.get(node).size(); i++) {                if (vis[adj.get(node).get(i)] == 0) {                    System.out.print(adj.get(node).get(i)                                     + \" \");                    q.add(adj.get(node).get(i));                }            }            System.out.println();        }    }    // Function to print the leaf nodes    public static void    printLeafNodes(int Root, Vector<Vector<Integer> > adj)    {        // Leaf nodes have only one edge and are not the        // root        for (int i = 1; i < adj.size(); i++)            if (adj.get(i).size() == 1 && i != Root)                System.out.print(i + \" \");        System.out.println();    }    // Function to print the degrees of each node    public static void    printDegrees(int Root, Vector<Vector<Integer> > adj)    {        for (int i = 1; i < adj.size(); i++) {            System.out.print(i + \": \");            // Root has no parent, thus, its degree is            // equal to the edges it is connected to            if (i == Root)                System.out.println(adj.get(i).size());            else                System.out.println(adj.get(i).size() - 1);        }    }    // Driver code    public static void main(String[] args)    {        // Number of nodes        int N = 7, Root = 1;        // Adjacency list to store the tree        Vector<Vector<Integer> > adj            = new Vector<Vector<Integer> >();        for (int i = 0; i < N + 1; i++) {            adj.add(new Vector<Integer>());        }        // Creating the tree        adj.get(1).add(2);        adj.get(2).add(1);        adj.get(1).add(3);        adj.get(3).add(1);        adj.get(1).add(4);        adj.get(4).add(1);        adj.get(2).add(5);        adj.get(5).add(2);        adj.get(2).add(6);        adj.get(6).add(2);        adj.get(4).add(7);        adj.get(7).add(4);        // Printing the parents of each node        System.out.println(\"The parents of each node are:\");        printParents(Root, adj, 0);        // Printing the children of each node        System.out.println(            \"The children of each node are:\");        printChildren(Root, adj);        // Printing the leaf nodes in the tree        System.out.println(            \"The leaf nodes of the tree are:\");        printLeafNodes(Root, adj);        // Printing the degrees of each node        System.out.println(\"The degrees of each node are:\");        printDegrees(Root, adj);    }}// This code is contributed by rj13to.",
              "python3": "classNode:def__init__(self,data):self.data=dataself.children=[]",
              "javascript": "// Number of nodeslet n = 7, root = 1;// Adjacency list to store the treelet adj = new Array(n + 1).fill(null).map(() => []);// Creating the treeaddEdge(1, 2, adj);addEdge(1, 3, adj);addEdge(1, 4, adj);addEdge(2, 5, adj);addEdge(2, 6, adj);addEdge(4, 7, adj);// Function to add an edge between vertices x and yfunction addEdge(x, y, arr) {    arr[x].push(y);    arr[y].push(x);}// Function to print the parent of each nodefunction printParents(node, arr, parent) {    // current node is Root, thus, has no parent    if (parent == 0)        console.log(`${node}->root`);    else        console.log(`${node}->${parent}`);            // Using DFS    for (let cur of arr[node])        if (cur != parent)            printParents(cur, arr, node);}// Function to print the children of each nodefunction printChildren(root, arr) {    // Queue for the BFS    let q = [];        // pushing the root    q.push(root);        // visit array to keep track of nodes    // that have been visited    let vis = new Array(arr.length).fill(0);        // BFS    while (q.length > 0) {        let node = q.shift();        vis[node] = 1;        console.log(`${node}-> `);        for (let cur of arr[node])            if (vis[cur] == 0) {                console.log(cur + \" \");                q.push(cur);            }        console.log(\"\\n\");    }}// Function to print the leaf nodesfunction printLeafNodes(root, arr) {    // Leaf nodes have only one edge    // and are not the root    for (let i = 1; i < arr.length; i++)        if (arr[i].length == 1 &&        i != root)            console.log(i + \" \");    console.log(\"\\n\");}// Function to print the degrees of each nodefunction printDegrees(Root, arr) {    for (let i = 1; i < arr.length; i++) {        console.log(`${i}: `);                // Root has no parent, thus, its degree is equal to        // the edges it is connected to        if (i == root)            console.log(arr[i].length + \"\\n\");        else            console.log(arr[i].length - 1 + \"\\n\");    }}// Function to print the tree in a hierarchical formatfunction printTree(node, arr, parent, level) {    // Indent based on the level of the node    console.log(\"  \".repeat(level) + \"└── \" + node);    // Recursively print children    for (let cur of arr[node])        if (cur != parent)            printTree(cur, arr, node, level + 1);}// Driver code// Printing the tree in a hierarchical formatconsole.log(\"Tree Structure:\");printTree(root, adj, 0, 0);// Printing the parents of each nodeconsole.log(\"\\nThe parents of each node are:\");printParents(root, adj, 0);// Printing the children of each nodeconsole.log(\"\\nThe children of each node are:\");printChildren(root, adj);// Printing the leaf nodes in the treeconsole.log(\"\\nThe leaf nodes of the tree are:\");printLeafNodes(root, adj);// Printing the degrees of each nodeconsole.log(\"\\nThe degrees of each node are:\");printDegrees(root, adj);",
              "python": "fromcollectionsimportdeque# Function to add an edge between vertices x and ydefaddEdge(x,y,adj):adj[x].append(y)adj[y].append(x)# Function to print the parent of each nodedefprintParents(node,adj,parent):# current node is Root, thus, has no parentifparent==0:print(\"{}->Root\".format(node))else:print(\"{}->{}\".format(node,parent))# Using DFSforcurinadj[node]:ifcur!=parent:printParents(cur,adj,node)# Function to print the children of each nodedefprintChildren(Root,adj):# Queue for the BFSq=deque()# pushing the rootq.append(Root)# visit array to keep track of nodes that have been# visitedvis=[0]*len(adj)# BFSwhileq:node=q.popleft()vis[node]=1print(\"{}->\".format(node)),forcurinadj[node]:ifvis[cur]==0:print(cur),q.append(cur)print()# Function to print the leaf nodesdefprintLeafNodes(Root,adj):# Leaf nodes have only one edge and are not the rootforiinrange(1,len(adj)):iflen(adj[i])==1andi!=Root:print(i),# Function to print the degrees of each nodedefprintDegrees(Root,adj):foriinrange(1,len(adj)):print(i,\":\"),# Root has no parent, thus, its degree is equal to# the edges it is connected toifi==Root:print(len(adj[i]))else:print(len(adj[i])-1)# Driver codeN=7Root=1# Adjacency list to store the treeadj=[[]for_inrange(N+1)]# Creating the treeaddEdge(1,2,adj)addEdge(1,3,adj)addEdge(1,4,adj)addEdge(2,5,adj)addEdge(2,6,adj)addEdge(4,7,adj)# Printing the parents of each nodeprint(\"The parents of each node are:\")printParents(Root,adj,0)# Printing the children of each nodeprint(\"The children of each node are:\")printChildren(Root,adj)# Printing the leaf nodes in the treeprint(\"The leaf nodes of the tree are:\")printLeafNodes(Root,adj)# Printing the degrees of each nodeprint(\"The degrees of each node are:\")printDegrees(Root,adj)",
              "csharp": "using System;using System.Collections.Generic;class GfG{    static void PrintParents(int node, List<List<int>> adj, int parent)    {        if (parent == 0)        {            Console.WriteLine($\"{node} -> Root\");        }        else        {            Console.WriteLine($\"{node} -> {parent}\");        }        foreach (int cur in adj[node])        {            if (cur != parent)            {                PrintParents(cur, adj, node);            }        }    }    static void PrintChildren(int Root, List<List<int>> adj)    {        Queue<int> q = new Queue<int>();        q.Enqueue(Root);        bool[] vis = new bool[adj.Count];        while (q.Count > 0)        {            int node = q.Dequeue();            vis[node] = true;            Console.Write($\"{node} -> \");            foreach (int cur in adj[node])            {                if (!vis[cur])                {                    Console.Write($\"{cur} \");                    q.Enqueue(cur);                }            }            Console.WriteLine();        }    }    static void PrintLeafNodes(int Root, List<List<int>> adj)    {        for (int i = 0; i < adj.Count; i++)        {            if (adj[i].Count == 1 && i != Root)            {                Console.Write($\"{i} \");            }        }        Console.WriteLine();    }    static void PrintDegrees(int Root, List<List<int>> adj)    {        for (int i = 1; i < adj.Count; i++)        {            Console.Write($\"{i}: \");            if (i == Root)            {                Console.WriteLine(adj[i].Count);            }            else            {                Console.WriteLine(adj[i].Count - 1);            }        }    }    static void Main(string[] args)    {        int N = 7;        int Root = 1;        List<List<int>> adj = new List<List<int>>();        for (int i = 0; i <= N; i++)        {            adj.Add(new List<int>());        }        adj[1].AddRange(new int[] { 2, 3, 4 });        adj[2].AddRange(new int[] { 1, 5, 6 });        adj[4].Add(7);        Console.WriteLine(\"The parents of each node are:\");        PrintParents(Root, adj, 0);        Console.WriteLine(\"The children of each node are:\");        PrintChildren(Root, adj);        Console.WriteLine(\"The leaf nodes of the tree are:\");        PrintLeafNodes(Root, adj);        Console.WriteLine(\"The degrees of each node are:\");        PrintDegrees(Root, adj);    }}"
            }
          }
        ]
      },
      {
        "subtopic_title": "Applications of tree data structure",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-of-tree-data-structure/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Uses of Tree Data Structure:",
            "content": "Unlike Array and Linked List, which are linear data structures, tree is hierarchical (or non-linear) data structure.\nHierarchical Structure: One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: The DOM model of an HTML page is also tree where we have html tag as root, head and body its children and these tags, then have their own children. DNS System is also example where we have natural hierarchy.\nSearching Efficiency: Trees provide an efficient way to search for data. For example, in a binary search tree, searching for a value takes time proportional to the logarithm of the number of elements, which is much faster than searching in a linear data structure like an array or a linked list.\nSorting: Trees can be used to sort data efficiently. For example, in a self-balancing binary search tree, the data is automatically sorted as it is inserted into the tree, making it easy to find the minimum, maximum, and other values in the tree.\nDynamic Data: Trees are dynamic data structures, which means that they can grow and shrink as needed. This makes them well-suited for applications where the data changes frequently, such as in real-time systems.\nEfficient Insertion and Deletion: Trees provide efficient algorithms for inserting and deleting data, which is important in many applications where data needs to be added or removed frequently.\nEasy to Implement: Trees are relatively easy to implement, especially when compared to other data structures like graphs. This makes them a popular choice for many programming projects.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Other Applications of Tree Data Structure:",
            "content": "Store hierarchical data, like folder structure, organization structure, XML/HTML data.\nBinary Search Tree is a tree that allows fast search, insert, delete on a sorted data. It also allows finding closest item\nHeap is a tree data structure which is implemented using arrays and used to implement priority queues.\nB-Tree and B+ Tree : They are used to implement indexing in databases.\nSyntax Tree:  Scanning, parsing , generation of code and evaluation of arithmetic expressions in Compiler design.\nK-D Tree: A space partitioning tree used to organize points in K dimensional space.\nTrie : Used to implement dictionaries with prefix lookup.\nSuffix Tree : For quick pattern searching in a fixed text.\nSpanning Trees and shortest path trees are used in routers and bridges respectively in computer networks\nAs a workflow for compositing digital images for visual effects.\nDecision trees.\nOrganization chart of a large organization.\nIn XML parser.\nMachine learning algorithm.\nFor indexing in database.\nIN server like DNS (Domain Name Server)\nIn Computer Graphics.\nTo evaluate an expression.\nIn chess game to store defense moves of player.\nIn java virtual machine.\nTree data structures are used to organize and manage files and directories in a file system. Each file and directory is represented as a node in the tree, with parent-child relationships indicating the hierarchical structure of the file system.\nTree data structures are often used in parsing, such as in compilers and interpreters, to represent the structure of a program or a document.\nTree data structures, such as binary search trees, are commonly used to implement efficient searching and sorting algorithms.\n Graphics and UI design\n Tree data structures are commonly used in decision-making algorithms in artificial intelligence, such as game-playing algorithms, expert systems, and decision trees.\nTree data structures can be used to represent the topology of a network and to calculate routing tables for efficient data transmission.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Next Article :",
            "content": "Advantages, and Disadvantages of Tree\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "18. Heap",
    "main_article_link": "https://www.geeksforgeeks.org/heap-data-structure/",
    "subtopics": [
      {
        "subtopic_title": "Applications of Heap Data Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/applications-of-heap-data-structure/",
        "sub_subtopics": []
      },
      {
        "subtopic_title": "Binary Heap",
        "subtopic_url": "https://www.geeksforgeeks.org/binary-heap/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Valid and Invalid examples of heaps",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How is Binary Heap represented?",
            "content": "A Binary Heap is a Complete Binary Tree. A binary heap is typically represented as an array.\nThe root element will be at arr[0].\nThe below table shows indices of other nodes for the ith node, i.e., arr[i]:\nThe traversal method use to achieve Array representation is Level Order Traversal. Please refer to Array Representation Of Binary Heap for details.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Operations on Heap",
            "content": "Refer Introduction to Min-Heap – Data Structure and Algorithm Tutorials for more\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Heaps",
            "content": "Heap Sort: Heap Sort uses Binary Heap to sort an array in O(nLogn) time.\nPriority Queue: Priority queues can be efficiently implemented using Binary Heap because it supports insert(), delete() and extractmax(), decreaseKey() operations in O(log N) time. Binomial Heap and Fibonacci Heap are variations of Binary Heap. These variations perform union also efficiently.\nGraph Algorithms: The priority queues are especially used in Graph Algorithms like Dijkstra's Shortest Path and Prim's Minimum Spanning Tree.\nMany problems can be efficiently solved using Heaps.\nSee following for example. a) K'th Largest Element in an array. b) Sort an almost sorted array/ c) Merge K Sorted Arrays.\nRelated Links:\nCoding Practice on Heap \nAll Articles on Heap \nQuiz on Heap\n",
            "code_snippets": {
              "cpp": "// A C++ program to demonstrate common Binary Heap Operations#include<iostream>#include<climits>using namespace std;// Prototype of a utility function to swap two integersvoid swap(int *x, int *y);// A class for Min Heapclass MinHeap{    int *harr; // pointer to array of elements in heap    int capacity; // maximum possible size of min heap    int heap_size; // Current number of elements in min heappublic:    // Constructor    MinHeap(int capacity);    // to heapify a subtree with the root at given index    void MinHeapify(int i);    int parent(int i) { return (i-1)/2; }    // to get index of left child of node at index i    int left(int i) { return (2*i + 1); }    // to get index of right child of node at index i    int right(int i) { return (2*i + 2); }    // to extract the root which is the minimum element    int extractMin();    // Decreases key value of key at index i to new_val    void decreaseKey(int i, int new_val);    // Returns the minimum key (key at root) from min heap    int getMin() { return harr[0]; }    // Deletes a key stored at index i    void deleteKey(int i);    // Inserts a new key 'k'    void insertKey(int k);};// Constructor: Builds a heap from a given array a[] of given sizeMinHeap::MinHeap(int cap){    heap_size = 0;    capacity = cap;    harr = new int[cap];}// Inserts a new key 'k'void MinHeap::insertKey(int k){    if (heap_size == capacity)    {        cout << \"\\nOverflow: Could not insertKey\\n\";        return;    }    // First insert the new key at the end    heap_size++;    int i = heap_size - 1;    harr[i] = k;    // Fix the min heap property if it is violated    while (i != 0 && harr[parent(i)] > harr[i])    {       swap(&harr[i], &harr[parent(i)]);       i = parent(i);    }}// Decreases value of key at index 'i' to new_val.  It is assumed that// new_val is smaller than harr[i].void MinHeap::decreaseKey(int i, int new_val){    harr[i] = new_val;    while (i != 0 && harr[parent(i)] > harr[i])    {       swap(&harr[i], &harr[parent(i)]);       i = parent(i);    }}// Method to remove minimum element (or root) from min heapint MinHeap::extractMin(){    if (heap_size <= 0)        return INT_MAX;    if (heap_size == 1)    {        heap_size--;        return harr[0];    }    // Store the minimum value, and remove it from heap    int root = harr[0];    harr[0] = harr[heap_size-1];    heap_size--;    MinHeapify(0);    return root;}// This function deletes key at index i. It first reduced value to minus// infinite, then calls extractMin()void MinHeap::deleteKey(int i){    decreaseKey(i, INT_MIN);    extractMin();}// A recursive method to heapify a subtree with the root at given index// This method assumes that the subtrees are already heapifiedvoid MinHeap::MinHeapify(int i){    int l = left(i);    int r = right(i);    int smallest = i;    if (l < heap_size && harr[l] < harr[i])        smallest = l;    if (r < heap_size && harr[r] < harr[smallest])        smallest = r;    if (smallest != i)    {        swap(&harr[i], &harr[smallest]);        MinHeapify(smallest);    }}// A utility function to swap two elementsvoid swap(int *x, int *y){    int temp = *x;    *x = *y;    *y = temp;}// Driver program to test above functionsint main(){    MinHeap h(11);    h.insertKey(3);    h.insertKey(2);    h.deleteKey(1);    h.insertKey(15);    h.insertKey(5);    h.insertKey(4);    h.insertKey(45);    cout << h.extractMin() << \" \";    cout << h.getMin() << \" \";    h.decreaseKey(2, 1);    cout << h.getMin();    return 0;}",
              "java": "// Java program for the above approachimport java.util.*;// A class for Min Heap classMinHeap {        // To store array of elements in heap    private int[] heapArray;        // max size of the heap    private int capacity;        // Current number of elements in the heap    private int current_heap_size;    // Constructor     public MinHeap(int n) {        capacity = n;        heapArray = new int[capacity];        current_heap_size = 0;    }        // Swapping using reference     private void swap(int[] arr, int a, int b) {        int temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    }            // Get the Parent index for the given index    private int parent(int key) {        return (key - 1) / 2;    }        // Get the Left Child index for the given index    private int left(int key) {        return 2 * key + 1;    }        // Get the Right Child index for the given index    private int right(int key) {        return 2 * key + 2;    }            // Inserts a new key    public boolean insertKey(int key) {        if (current_heap_size == capacity) {                        // heap is full            return false;        }            // First insert the new key at the end         int i = current_heap_size;        heapArray[i] = key;        current_heap_size++;                // Fix the min heap property if it is violated         while (i != 0 && heapArray[i] < heapArray[parent(i)]) {            swap(heapArray, i, parent(i));            i = parent(i);        }        return true;    }        // Decreases value of given key to new_val.     // It is assumed that new_val is smaller     // than heapArray[key].     public void decreaseKey(int key, int new_val) {        heapArray[key] = new_val;        while (key != 0 && heapArray[key] < heapArray[parent(key)]) {            swap(heapArray, key, parent(key));            key = parent(key);        }    }        // Returns the minimum key (key at    // root) from min heap     public int getMin() {        return heapArray[0];    }            // Method to remove minimum element     // (or root) from min heap     public int extractMin() {        if (current_heap_size <= 0) {            return Integer.MAX_VALUE;        }        if (current_heap_size == 1) {            current_heap_size--;            return heapArray[0];        }                // Store the minimum value,         // and remove it from heap         int root = heapArray[0];        heapArray[0] = heapArray[current_heap_size - 1];        current_heap_size--;        MinHeapify(0);        return root;    }            // This function deletes key at the     // given index. It first reduced value     // to minus infinite, then calls extractMin()    public void deleteKey(int key) {        decreaseKey(key, Integer.MIN_VALUE);        extractMin();    }        // A recursive method to heapify a subtree     // with the root at given index     // This method assumes that the subtrees    // are already heapified    private void MinHeapify(int key) {        int l = left(key);        int r = right(key);        int smallest = key;        if (l < current_heap_size && heapArray[l] < heapArray[smallest]) {            smallest = l;        }        if (r < current_heap_size && heapArray[r] < heapArray[smallest]) {            smallest = r;        }        if (smallest != key) {            swap(heapArray, key, smallest);            MinHeapify(smallest);        }    }        // Increases value of given key to new_val.    // It is assumed that new_val is greater     // than heapArray[key].     // Heapify from the given key    public void increaseKey(int key, int new_val) {        heapArray[key] = new_val;        MinHeapify(key);    }        // Changes value on a key    public void changeValueOnAKey(int key, int new_val) {        if (heapArray[key] == new_val) {            return;        }        if (heapArray[key] < new_val) {            increaseKey(key, new_val);        } else {            decreaseKey(key, new_val);        }    }}// Driver CodeclassMinHeapTest {    public static void main(String[] args) {        MinHeap h = new MinHeap(11);        h.insertKey(3);        h.insertKey(2);        h.deleteKey(1);        h.insertKey(15);        h.insertKey(5);        h.insertKey(4);        h.insertKey(45);        System.out.print(h.extractMin() + \" \");        System.out.print(h.getMin() + \" \");                h.decreaseKey(2, 1);        System.out.print(h.getMin());    }}// This code is contributed by rishabmalhdijo",
              "python": "# A Python program to demonstrate common binary heap operations# Import the heap functions from python libraryfromheapqimportheappush,heappop,heapify# heappop - pop and return the smallest element from heap# heappush - push the value item onto the heap, maintaining#             heap invarient# heapify - transform list into heap, in place, in linear time# A class for Min HeapclassMinHeap:# Constructor to initialize a heapdef__init__(self):self.heap=[]defparent(self,i):return(i-1)/2# Inserts a new key 'k'definsertKey(self,k):heappush(self.heap,k)# Decrease value of key at index 'i' to new_val# It is assumed that new_val is smaller than heap[i]defdecreaseKey(self,i,new_val):self.heap[i]=new_valwhile(i!=0andself.heap[self.parent(i)]>self.heap[i]):# Swap heap[i] with heap[parent(i)]self.heap[i],self.heap[self.parent(i)]=(self.heap[self.parent(i)],self.heap[i])# Method to remove minimum element from min heapdefextractMin(self):returnheappop(self.heap)# This function deletes key at index i. It first reduces# value to minus infinite and then calls extractMin()defdeleteKey(self,i):self.decreaseKey(i,float(\"-inf\"))self.extractMin()# Get the minimum element from the heapdefgetMin(self):returnself.heap[0]# Driver pgoratm to test above functionheapObj=MinHeap()heapObj.insertKey(3)heapObj.insertKey(2)heapObj.deleteKey(1)heapObj.insertKey(15)heapObj.insertKey(5)heapObj.insertKey(4)heapObj.insertKey(45)printheapObj.extractMin(),printheapObj.getMin(),heapObj.decreaseKey(2,1)printheapObj.getMin()# This code is contributed by Nikhil Kumar Singh(nickzuck_007)",
              "csharp": "// C# program to demonstrate common // Binary Heap Operations - Min Heapusing System;// A class for Min Heap class MinHeap{    // To store array of elements in heappublic int[] heapArray{ get; set; }// max size of the heappublic int capacity{ get; set; }// Current number of elements in the heappublic int current_heap_size{ get; set; }// Constructor public MinHeap(int n){    capacity = n;    heapArray = new int[capacity];    current_heap_size = 0;}// Swapping using reference public static void Swap<T>(ref T lhs, ref T rhs){    T temp = lhs;    lhs = rhs;    rhs = temp;}// Get the Parent index for the given indexpublic int Parent(int key) {    return (key - 1) / 2;}// Get the Left Child index for the given indexpublic int Left(int key){    return 2 * key + 1;}// Get the Right Child index for the given indexpublic int Right(int key){    return 2 * key + 2;}// Inserts a new keypublic bool insertKey(int key){    if (current_heap_size == capacity)    {                // heap is full        return false;    }    // First insert the new key at the end     int i = current_heap_size;    heapArray[i] = key;    current_heap_size++;    // Fix the min heap property if it is violated     while (i != 0 && heapArray[i] <                      heapArray[Parent(i)])    {        Swap(ref heapArray[i],             ref heapArray[Parent(i)]);        i = Parent(i);    }    return true;}// Decreases value of given key to new_val. // It is assumed that new_val is smaller // than heapArray[key]. public void decreaseKey(int key, int new_val){    heapArray[key] = new_val;    while (key != 0 && heapArray[key] <                        heapArray[Parent(key)])    {        Swap(ref heapArray[key],              ref heapArray[Parent(key)]);        key = Parent(key);    }}// Returns the minimum key (key at// root) from min heap public int getMin(){    return heapArray[0];}// Method to remove minimum element // (or root) from min heap public int extractMin(){    if (current_heap_size <= 0)    {        return int.MaxValue;    }    if (current_heap_size == 1)    {        current_heap_size--;        return heapArray[0];    }    // Store the minimum value,     // and remove it from heap     int root = heapArray[0];    heapArray[0] = heapArray[current_heap_size - 1];    current_heap_size--;    MinHeapify(0);    return root;}// This function deletes key at the // given index. It first reduced value // to minus infinite, then calls extractMin()public void deleteKey(int key){    decreaseKey(key, int.MinValue);    extractMin();}// A recursive method to heapify a subtree // with the root at given index // This method assumes that the subtrees// are already heapifiedpublic void MinHeapify(int key){    int l = Left(key);    int r = Right(key);    int smallest = key;    if (l < current_heap_size &&         heapArray[l] < heapArray[smallest])    {        smallest = l;    }    if (r < current_heap_size &&         heapArray[r] < heapArray[smallest])    {        smallest = r;    }        if (smallest != key)    {        Swap(ref heapArray[key],              ref heapArray[smallest]);        MinHeapify(smallest);    }}// Increases value of given key to new_val.// It is assumed that new_val is greater // than heapArray[key]. // Heapify from the given keypublic void increaseKey(int key, int new_val){    heapArray[key] = new_val;    MinHeapify(key);}// Changes value on a keypublic void changeValueOnAKey(int key, int new_val){    if (heapArray[key] == new_val)    {        return;    }    if (heapArray[key] < new_val)    {        increaseKey(key, new_val);    } else    {        decreaseKey(key, new_val);    }}}static class MinHeapTest{    // Driver codepublic static void Main(string[] args){    MinHeap h = new MinHeap(11);    h.insertKey(3);    h.insertKey(2);    h.deleteKey(1);    h.insertKey(15);    h.insertKey(5);    h.insertKey(4);    h.insertKey(45);        Console.Write(h.extractMin() + \" \");    Console.Write(h.getMin() + \" \");        h.decreaseKey(2, 1);    Console.Write(h.getMin());}}// This code is contributed by // Dinesh Clinton Albert(dineshclinton)",
              "javascript": "// A class for Min Heapclass MinHeap{    // Constructor: Builds a heap from a given array a[] of given size    constructor()    {        this.arr = [];    }    left(i) {        return 2*i + 1;    }    right(i) {        return 2*i + 2;    }    parent(i){        return Math.floor((i - 1)/2)    }        getMin()    {        return this.arr[0]    }        insert(k)    {        let arr = this.arr;        arr.push(k);            // Fix the min heap property if it is violated        let i = arr.length - 1;        while (i > 0 && arr[this.parent(i)] > arr[i])        {            let p = this.parent(i);            [arr[i], arr[p]] = [arr[p], arr[i]];            i = p;        }    }    // Decreases value of key at index 'i' to new_val.     // It is assumed that new_val is smaller than arr[i].    decreaseKey(i, new_val)    {        let arr = this.arr;        arr[i] = new_val;                while (i !== 0 && arr[this.parent(i)] > arr[i])        {           let p = this.parent(i);           [arr[i], arr[p]] = [arr[p], arr[i]];           i = p;        }    }    // Method to remove minimum element (or root) from min heap    extractMin()    {        let arr = this.arr;        if (arr.length == 1) {            return arr.pop();        }                // Store the minimum value, and remove it from heap        let res = arr[0];        arr[0] = arr[arr.length-1];        arr.pop();        this.MinHeapify(0);        return res;    }    // This function deletes key at index i. It first reduced value to minus    // infinite, then calls extractMin()    deleteKey(i)    {        this.decreaseKey(i, this.arr[0] - 1);        this.extractMin();    }    // A recursive method to heapify a subtree with the root at given index    // This method assumes that the subtrees are already heapified    MinHeapify(i)    {        let arr = this.arr;        let n = arr.length;        if (n === 1) {            return;        }        let l = this.left(i);        let r = this.right(i);        let smallest = i;        if (l < n && arr[l] < arr[i])            smallest = l;        if (r < n && arr[r] < arr[smallest])            smallest = r;        if (smallest !== i)        {            [arr[i], arr[smallest]] = [arr[smallest], arr[i]]            this.MinHeapify(smallest);        }    }}let h = new MinHeap();    h.insert(3);     h.insert(2);    h.deleteKey(1);    h.insert(15);    h.insert(5);    h.insert(4);    h.insert(45);        console.log(h.extractMin() + \" \");    console.log(h.getMin() + \" \");        h.decreaseKey(2, 1);     console.log(h.extractMin());"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "19. Graph",
    "main_article_link": "https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "Graph and its representations",
        "subtopic_url": "https://www.geeksforgeeks.org/graph-and-its-representations/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Representations of Graph",
            "content": "Here are the two most common ways to represent a graph : For simplicity, we are going to consider only unweighted graphs in this post.\nAdjacency Matrix\nAdjacency List\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Adjacency Matrix Representation",
            "content": "An adjacency matrix is a way of representing a graph as a matrix of boolean (0's and 1's)\nLet's assume there are n vertices in the graph So, create a 2D matrix adjMat[n][n] having dimension n x n.\nIf there is an edge from vertex i to j, mark adjMat[i][j] as 1. \nIf there is no edge from vertex i to j, mark adjMat[i][j] as 0.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Undirected Graph as Adjacency Matrix:",
            "content": "The below figure shows an undirected graph. Initially, the entire Matrix is initialized to 0. If there is an edge from source to destination, we insert 1 to both cases (adjMat[source][destination] and adjMat[destination][source]) because we can go either way.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Directed Graph as Adjacency Matrix:",
            "content": "The below figure shows a directed graph. Initially, the entire Matrix is initialized to 0. If there is an edge from source to destination, we insert 1 for that particular adjMat[source][destination].\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Adjacency List Representation",
            "content": "An array of Lists is used to store edges between two vertices. The size of array is equal to the number of vertices (i.e, n). Each index in this array represents a specific vertex in the graph. The entry at the index i of the array contains a linked list containing the vertices that are adjacent to vertex i.\nLet's assume there are n vertices in the graph So, create an array of list of size n as adjList[n].\nadjList[0] will have all the nodes which are connected (neighbour) to vertex 0.\nadjList[1] will have all the nodes which are connected (neighbour) to vertex 1 and so on.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Undirected Graph as Adjacency list:",
            "content": "The below undirected graph has 3 vertices. So, an array of list will be created of size 3, where each indices represent the vertices. Now, vertex 0 has two neighbours (i.e, 1 and 2). So, insert vertex 1 and 2 at indices 0 of array. Similarly, For vertex 1, it has two neighbour (i.e, 2 and 0) So, insert vertices 2 and 0 at indices 1 of array. Similarly, for vertex 2, insert its neighbours in array of list.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Representation of Directed Graph as Adjacency list:",
            "content": "The below directed graph has 3 vertices. So, an array of list will be created of size 3, where each indices represent the vertices. Now, vertex 0 has no neighbours. For vertex 1, it has two neighbour (i.e, 0 and 2) So, insert vertices 0 and 2 at indices 1 of array. Similarly, for vertex 2, insert its neighbours in array of list.\n",
            "code_snippets": {
              "cpp": "#include <iostream>#include <vector>using namespace std;// Function to add an edge between two verticesvoid addEdge(vector<vector<int>>& adj, int i, int j) {    adj[i].push_back(j);    adj[j].push_back(i); // Undirected}// Function to display the adjacency listvoid displayAdjList(const vector<vector<int>>& adj) {    for (int i = 0; i < adj.size(); i++) {        cout << i << \": \"; // Print the vertex        for (int j : adj[i]) {            cout << j << \" \"; // Print its adjacent        }        cout << endl;     }}// Main functionint main() {    // Create a graph with 4 vertices and no edges    int V = 4;    vector<vector<int>> adj(V);     // Now add edges one by one    addEdge(adj, 0, 1);    addEdge(adj, 0, 2);    addEdge(adj, 1, 2);    addEdge(adj, 2, 3);    cout << \"Adjacency List Representation:\" << endl;    displayAdjList(adj);    return 0;}",
              "c": "#include <stdio.h>#include <stdlib.h>// Structure for a node in the adjacency liststruct Node {    int data;    struct Node* next;};// Function to create a new nodestruct Node* createNode(int data) {    struct Node* newNode =       (struct Node*)malloc(sizeof(struct Node));    newNode->data = data;    newNode->next = NULL;    return newNode;}// Function to add an edge between two verticesvoid addEdge(struct Node* adj[], int i, int j) {    struct Node* newNode = createNode(j);    newNode->next = adj[i];    adj[i] = newNode;    newNode = createNode(i); // For undirected graph    newNode->next = adj[j];    adj[j] = newNode;}// Function to display the adjacency listvoid displayAdjList(struct Node* adj[], int V) {    for (int i = 0; i < V; i++) {        printf(\"%d: \", i); // Print the vertex        struct Node* temp = adj[i];        while (temp != NULL) {            printf(\"%d \", temp->data); // Print its adjacent            temp = temp->next;        }        printf(\"\\n\");    }}// Main functionint main() {      // Create a graph with 4 vertices and no edges    int V = 4;    struct Node* adj[V];    for (int i = 0; i < V; i++) {        adj[i] = NULL; // Initialize adjacency list    }    // Now add edges one by one    addEdge(adj, 0, 1);    addEdge(adj, 0, 2);    addEdge(adj, 1, 2);    addEdge(adj, 2, 3);    printf(\"Adjacency List Representation:\\n\");    displayAdjList(adj, V);    return 0;}",
              "java": "import java.util.ArrayList;import java.util.List;public classGfG {        // Method to add an edge between two vertices    public static void addEdge(List<List<Integer>> adj, int i, int j) {        adj.get(i).add(j);        adj.get(j).add(i); // Undirected    }    // Method to display the adjacency list    public static void displayAdjList(List<List<Integer>> adj) {        for (int i = 0; i < adj.size(); i++) {            System.out.print(i + \": \"); // Print the vertex            for (int j : adj.get(i)) {                System.out.print(j + \" \"); // Print its adjacent             }            System.out.println();         }    }    // Main method    public static void main(String[] args) {              // Create a graph with 4 vertices and no edges        int V = 4;        List<List<Integer>> adj = new ArrayList<>(V);         for (int i = 0; i < V; i++) {            adj.add(new ArrayList<>());        }        // Now add edges one by one        addEdge(adj, 0, 1);        addEdge(adj, 0, 2);        addEdge(adj, 1, 2);        addEdge(adj, 2, 3);        System.out.println(\"Adjacency List Representation:\");        displayAdjList(adj);    }}",
              "python3": "defadd_edge(adj,i,j):adj[i].append(j)adj[j].append(i)# Undirecteddefdisplay_adj_list(adj):foriinrange(len(adj)):print(f\"{i}: \",end=\"\")forjinadj[i]:print(j,end=\" \")print()# Create a graph with 4 vertices and no edgesV=4adj=[[]for_inrange(V)]# Now add edges one by oneadd_edge(adj,0,1)add_edge(adj,0,2)add_edge(adj,1,2)add_edge(adj,2,3)print(\"Adjacency List Representation:\")display_adj_list(adj)",
              "csharp": "using System;using System.Collections.Generic;public class GfG{    // Method to add an edge between two vertices    public static void AddEdge(List<List<int>> adj, int i, int j)    {        adj[i].Add(j);        adj[j].Add(i); // Undirected    }    // Method to display the adjacency list    public static void DisplayAdjList(List<List<int>> adj)    {        for (int i = 0; i < adj.Count; i++)        {            Console.Write($\"{i}: \"); // Print the vertex            foreach (int j in adj[i])            {                Console.Write($\"{j} \"); // Print its adjacent            }            Console.WriteLine();         }    }    // Main method    public static void Main(string[] args)    {        // Create a graph with 4 vertices and no edges        int V = 4;        List<List<int>> adj = new List<List<int>>(V);         for (int i = 0; i < V; i++)            adj.Add(new List<int>());        // Now add edges one by one        AddEdge(adj, 0, 1);        AddEdge(adj, 0, 2);        AddEdge(adj, 1, 2);        AddEdge(adj, 2, 3);        Console.WriteLine(\"Adjacency List Representation:\");        DisplayAdjList(adj);    }}",
              "javascript": "function addEdge(adj, i, j) {    adj[i].push(j);    adj[j].push(i); // Undirected}function displayAdjList(adj) {    for (let i = 0; i < adj.length; i++) {        console.log(`${i}: `);         for (const j of adj[i]) {             console.log(`${j} `);         }        console.log();     }}// Create a graph with 4 vertices and no edgesconst V = 4;const adj = Array.from({ length: V }, () => []);// Now add edges one by oneaddEdge(adj, 0, 1);addEdge(adj, 0, 2);addEdge(adj, 1, 2);addEdge(adj, 2, 3);console.log(\"Adjacency List Representation:\");displayAdjList(adj);"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "20. Greedy Algorithm",
    "main_article_link": "https://www.geeksforgeeks.org/greedy-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "Greedy Algorithm Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Characteristics of Greedy Algorithm",
            "content": "Here are the characteristics of a greedy algorithm:\nGreedy algorithms are simple and easy to implement.\nThey are efficient in terms of time complexity, often providing quick solutions. Greedy Algorithms are typically preferred over Dynamic Programming for the problems where both are applied. For example, Jump Game problem and Single Source Shortest Path Problem (Dijkstra is preferred over Bellman Ford where we do not have negative weights).\nThese algorithms do not reconsider previous choices, as they make decisions based on current information without looking ahead.\nThese characteristics help to define the nature and usage of greedy algorithms in problem-solving.\nWant to master  Greedy algorithm  and more? Check out our DSA Self-Paced Course  for a comprehensive guide to Data Structures and Algorithms at your own pace. This course will help you build a strong foundation and advance your problem-solving skills.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How does the Greedy Algorithm works?",
            "content": "Greedy Algorithm solve optimization problems by making the best local choice at each step in the hope of finding the global optimum. It's like taking the best option available at each moment, hoping it will lead to the best overall outcome.\nHere's how it works:\nStart with the initial state of the problem. This is the starting point from where you begin making choices.\nEvaluate all possible choices you can make from the current state. Consider all the options available at that specific moment.\nChoose the option that seems best at that moment, regardless of future consequences. This is the \"greedy\" part - you take the best option available now, even if it might not be the best in the long run.\nMove to the new state based on your chosen option. This becomes your new starting point for the next iteration.\nRepeat steps 2-4 until you reach the goal state or no further progress is possible. Keep making the best local choices until you reach the end of the problem or get stuck.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Example:",
            "content": "Let's say you have a set of coins with values [1, 2, 5, 10] and you need to give minimum number of coin to someone change for 39.\nThe greedy algorithm for making change would work as follows:\nStep-1: Start with the largest coin value that is less than or equal to the amount to be changed. In this case, the largest coin less than or equal to 39 is 10.\nStep- 2: Subtract the largest coin value from the amount to be changed, and add the coin to the solution. In this case, subtracting 10 from 39 gives 29, and we add one 10-coin to the solution.\nRepeat steps 1 and 2 until the amount to be changed becomes 0.\nBelow is the illustration of above example:\nThe greedy algorithm is not always the optimal solution for every optimization problem, as shown in the example below.\nWhen using the greedy approach to make change for the amount 20 with the coin denominations [18, 1, 10], the algorithm starts by selecting the largest coin value that is less than or equal to the target amount. In this case, the largest coin is 18, so the algorithm selects one 18 coin. After subtracting 18 from 20, the remaining amount is 2.\nAt this point, the greedy algorithm chooses the next largest coin less than or equal to 2, which is 1. It then selects two 1 coins to make up the remaining amount. So, the greedy approach results in using one 18 coin and two 1 coins.\nHowever, the greedy approach fails to find the optimal solution in this case. Although it uses three coins, a better solution would have been to use two 10 coins, resulting in a total of only two coins (10 + 10 = 20).\nRelated Articles:\nGreedy Algorithms General Structure\nTop 20 Greedy Algorithms Interview Questions\nMost recent published articles on Greedy Algorithm\nPractice problems on Greedy Algorithms\n",
            "code_snippets": {
              "cpp": "// C++ Program to find the minimum number of coins// to construct a given amount using greedy approach#include <iostream>#include <vector>#include <algorithm>using namespace std;int minCoins(vector<int> &coins, int amount) {    int n = coins.size();    sort(coins.begin(), coins.end());    int res = 0;      // Start from the coin with highest denomination    for(int i = n - 1; i >= 0; i--) {    \tif(amount >= coins[i]) {                      // Find the maximum number of ith coin             // we can use            int cnt = (amount / coins[i]);                      // Add the count to result        \tres += cnt;                      // Subtract the corresponding amount from            // the total amount            amount -= (cnt * coins[i]);        }              // Break if there is no amount left        if(amount == 0)            break;    }    return res;}int main() {    vector<int> coins = {5, 2, 10, 1};    int amount = 39;      cout << minCoins(coins, amount);    return 0;}",
              "c": "// C Program to find the minimum number of coins// to construct a given amount using greedy approach#include <stdio.h>#include <stdlib.h>int compare(const void *a, const void *b) {    return (*(int *)b - *(int *)a);}int minCoins(int coins[], int n, int amount) {      // Sort the coins in descending order    qsort(coins, n, sizeof(int), compare);      int res = 0;      // Start from the coin with highest denomination    for(int i = 0; i < n; i++) {        if(amount >= coins[i]) {                      // Find the maximum number of ith coin             // we can use            int cnt = (amount / coins[i]);                      // Add the count to result            res += cnt;                      // Subtract the corresponding amount from            // the total amount            amount -= (cnt * coins[i]);        }              // Break if there is no amount left        if(amount == 0)            break;    }    return res;}int main() {    int coins[] = {5, 2, 10, 1};    int n = sizeof(coins) / sizeof(coins[0]);    int amount = 39;      printf(\"%d\", minCoins(coins, n, amount));    return 0;}",
              "java": "// Java Program to find the minimum number of coins// to construct a given amount using greedy approachimport java.util.Arrays;classGfG {    static int minCoins(int[] coins, int amount) {        int n = coins.length;        Arrays.sort(coins);          int res = 0;                // Start from the coin with highest denomination        for (int i = n - 1; i >= 0; i--) {            if (amount >= coins[i]) {                              // Find the maximum number of ith coin we can use                int cnt = (amount / coins[i]);                                // Add the count to result                res += cnt;                                // Subtract the corresponding amount from                 // the total amount                amount -= (cnt * coins[i]);            }                        // Break if there is no amount left            if (amount == 0)                break;        }        return res;    }    public static void main(String[] args) {        int[] coins = {5, 2, 10, 1};        int amount = 39;              System.out.println(minCoins(coins, amount));    }}",
              "python3": "# Python Program to find the minimum number of coins# to construct a given amount using greedy approachdefminCoins(coins,amount):n=len(coins)coins.sort()res=0# Start from the coin with highest denominationforiinrange(n-1,-1,-1):ifamount>=coins[i]:# Find the maximum number of ith coin we can usecnt=amount//coins[i]# Add the count to resultres+=cnt# Subtract the corresponding amount from the total amountamount-=cnt*coins[i]# Break if there is no amount leftifamount==0:breakreturnresif__name__==\"__main__\":coins=[5,2,10,1]amount=39print(minCoins(coins,amount))",
              "csharp": "// C# Program to find the minimum number of coins// to construct a given amount using greedy approachusing System;class GfG {    static int minCoins(int[] coins, int amount) {        int n = coins.Length;        Array.Sort(coins);         int res = 0;        // Start from the coin with highest denomination        for (int i = n - 1; i >= 0; i--) {            if (amount >= coins[i]) {                              // Find the maximum number of ith coin we can use                int cnt = (amount / coins[i]);                // Add the count to result                res += cnt;                // Subtract the corresponding amount from the total amount                amount -= (cnt * coins[i]);            }            // Break if there is no amount left            if (amount == 0)                break;        }        return res;    }    static void Main() {        int[] coins = { 5, 2, 10, 1 };        int amount = 39;              Console.WriteLine(minCoins(coins, amount));    }}",
              "javascript": "// JavaScript Program to find the minimum number of coins// to construct a given amount using greedy approachfunction minCoins(coins, amount) {    let n = coins.length;    coins.sort((a, b) => a - b);     let res = 0;    // Start from the coin with highest denomination    for (let i = n - 1; i >= 0; i--) {        if (amount >= coins[i]) {            // Find the maximum number of ith coin we can use            let cnt = Math.floor(amount / coins[i]);            // Add the count to result            res += cnt;            // Subtract the corresponding amount from the total amount            amount -= (cnt * coins[i]);        }        // Break if there is no amount left        if (amount === 0)            break;    }    return res;}// Driver codelet coins = [5, 2, 10, 1];let amount = 39;console.log(minCoins(coins, amount));"
            }
          }
        ]
      },
      {
        "subtopic_title": "Greedy Algorithms General Structure",
        "subtopic_url": "https://www.geeksforgeeks.org/greedy-algorithms-general-structure-and-applications/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Problem structure:",
            "content": "Most of the problems where greedy algorithms work follow these two properties:\n1). Greedy Choice Property:- This property states that choosing the best possible option at each step will lead to the best overall solution. If this is not true, a greedy approach may not work.\n2). Optimal Substructure:- This means that you can break the problem down into smaller parts, and solving these smaller parts by making greedy choices helps solve the overall problem.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How to Identify Greedy Problems:",
            "content": "There are two major ways to detect greedy problems -\n1). Can we break the problem into smaller parts? If so, and solving those parts helps us solve the main problem, it probably would be solved using greedy approach. For example - In activity selection problem, once we have selected a activity then remaining subproblem is to choose those activities that start after the selected activity.\n2). Will choosing the best option at each step lead to the best overall solution? If yes, then a greedy algorithm could be a good choice. For example - In Dijkstra’s shortest path algorithm, choosing the minimum-cost edge at each step guarantees the shortest path.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Difference between Greedy and Dynamic Programming:",
            "content": "1). Greedy algorithm works when the problem has Greedy Choice Property and Optimal Substructure, Dynamic programming also works when a problem has optimal substructure but it also requires Overlapping Subproblems.\n2). In greedy algorithm each local decision leads to an optimal solution for the entire problem whereas in dynamic programming solution to the main problem depends on the overlapping subproblems.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Some common ways to solve Greedy Problems:",
            "content": "1). Sorting\nJob Sequencing:- In order to maximize profits, we prioritize jobs with higher profits. So we sort them in descending order based on profit. For each job, we try to schedule it as late as possible within its deadline to leave earlier slots open for other jobs with closer deadlines.\nActivity Selection:- To maximize the number of non-overlapping activities, we prioritize activities that end earlier, which helps us to select more activities. Therefore, we sort them based on their end times in ascending order. Then, we select the first activity and continue adding subsequent activities that start after the previous one has ended.\nDisjoint Intervals:- The approach for this problem is exactly similar to previous one, we sort the intervals based on their start or end times in ascending order. Then, select the first interval and continue adding next intervals that start after the previous one ends.\nFractional Knapsack:- The basic idea is to calculate the ratio profit/weight for each item and sort the item on the basis of this ratio. Then take the item with the highest ratio and add them as much as we can (can be the whole element or a fraction of it).\nKruskal Algorithm:- To find the Minimum Spanning Tree (MST), we prioritize edges with the smallest weights to minimize the overall cost. We start by sorting all the edges in ascending order based on their weights. Then, we iteratively add edges to the MST while ensuring that adding an edge does not form a cycle.\n2). Using Priority Queue or Heaps\nDijkstra Algorithm:- To find the shortest path from a source node to all other nodes in a graph, we prioritize nodes based on the smallest distance from the source node. We begin by initializing the distances and using a min-priority queue. In each iteration, we extract the node with the minimum distance from the priority queue and update the distances of its neighboring nodes. This process continues until all nodes have been processed, ensuring that we find the shortest paths efficiently.\nConnect N ropes:- In this problem, the lengths of the ropes picked first are counted multiple times in the total cost. Therefore, the strategy is to connect the two smallest ropes at each step and repeat the process for the remaining ropes. To implement this, we use a min-heap to store all the ropes. In each operation, we extract the top two elements from the heap, add their lengths, and then insert the sum back into the heap. We continue this process until only one rope remains.\nHuffman Encoding:- To compress data efficiently, we assign shorter codes to more frequent characters and longer codes to less frequent ones. We start by creating a min-heap that contains all characters and their frequencies. In each iteration, we extract the two nodes with the smallest frequencies, combine them into a new node, and insert this new node back into the heap. This process continues until there is only one node left in the heap.\n3). Arbitrary\nMinimum Number of Jumps To Reach End:- In this problem we maintain a variable to store maximum reachable position at within the current jump's range and increment the jump counter when the current jump range has been traversed. We stop this process when the maximum reachable position at any point is greater than or equal to the last index value.\n",
            "code_snippets": {}
          }
        ]
      }
    ]
  },
  {
    "topic_name": "21. Dynamic Programming",
    "main_article_link": "https://www.geeksforgeeks.org/dynamic-programming/",
    "subtopics": [
      {
        "subtopic_title": "Dynamic Programming (DP) Introduction",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "When to Use Dynamic Programming (DP)?",
            "content": "Dynamic programming is used for solving problems that consists of the following characteristics:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Optimal Substructure:",
            "content": "The property Optimal substructure means that we use the optimal results of subproblems to achieve the optimal result of the bigger problem.\nExample:\nConsider the problem of finding the minimum cost path in a weighted graph from a source node to a destination node. We can break this problem down into smaller subproblems:\nFind the minimum cost path from the source node to each intermediate node.\nFind the minimum cost path from each intermediate node to the destination node.\nThe solution to the larger problem (finding the minimum cost path from the source node to the destination node) can be constructed from the solutions to these smaller subproblems.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Overlapping Subproblems:",
            "content": "The same subproblems are solved repeatedly in different parts of the problem refer to Overlapping Subproblems Property in Dynamic Programming.\nExample:\nConsider the problem of computing the Fibonacci series. To compute the Fibonacci number at index n, we need to compute the Fibonacci numbers at indices n-1 and n-2. This means that the subproblem of computing the Fibonacci number at index n-2 is used twice (note that the call for n - 1 will make two calls, one for n-2 and other for n-3) in the solution to the larger problem of computing the Fibonacci number at index n. \nYou may notice overlapping subproblems highlighted in the second recursion tree for Nth Fibonacci diagram shown below.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Approaches of Dynamic Programming (DP)",
            "content": "Dynamic programming can be achieved using two approaches:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Top-Down Approach (Memoization):",
            "content": "In the top-down approach, also known as memoization, we keep the solution recursive and add a memoization table to avoid repeated calls of same subproblems.\nBefore making any recursive call, we first check if the memoization table already has solution for it.\nAfter the recursive call is over, we store the solution in the memoization table.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Bottom-Up Approach (Tabulation):",
            "content": "In the bottom-up approach, also known as tabulation, we start with the smallest subproblems and gradually build up to the final solution.\nWe write an iterative solution (avoid recursion overhead) and build the solution in bottom-up manner.\nWe use a dp table where we first fill the solution for base cases and then fill the remaining entries of the table using recursive formula.\nWe only use recursive formula on table entries and do not make recursive calls.\nPlease refer Tabulation vs Memoization for the detailed differences.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Example of Dynamic Programming (DP)",
            "content": "Example 1: Consider the problem of finding the Fibonacci sequence:\nFibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...\nBrute Force Approach: To find the nth Fibonacci number using a brute force approach, you would simply add the (n-1)th and (n-2)th Fibonacci numbers.\nBelow is the recursion tree of the above recursive solution.\nThe time complexity of the above approach is exponential and upper bounded by O(2n) as we make two recursive calls in every function.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How will Dynamic Programming (DP) Work?",
            "content": "Let’s us now see the above recursion tree with overlapping subproblems highlighted with same color. We can clearly see that that recursive solution is doing a lot work again and again which is causing the time complexity to be exponential. Imagine time taken for computing a large Fibonacci number.\nIdentify Subproblems: Divide the main problem into smaller, independent subproblems, i.e., F(n-1) and F(n-2)\nStore Solutions: Solve each subproblem and store the solution in a table or array so that we do not have to recompute the same again.\nBuild Up Solutions: Use the stored solutions to build up the solution to the main problem. For F(n), look up F(n-1) and F(n-2) in the table and add them.\nAvoid Recomputation: By storing solutions, DP ensures that each subproblem (for example, F(2)) is solved only once, reducing computation time.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Memoization Approach - O(n) Time and O(n) Space",
            "content": "To achieve this in our example we simply take an memo array initialized to -1. As we make a recursive call, we first check if the value stored in the memo array corresponding to that position is -1. The value -1 indicates that we haven't calculated it yet and have to recursively compute it. The output must be stored in the memo array so that, next time, if the same value is encountered, it can be directly used from the memo array.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Tabulation Approach - O(n) Time and O(n) Space",
            "content": "In this approach, we use an array of size (n + 1), often called dp[], to store Fibonacci numbers. The array is initialized with base values at the appropriate indices, such as dp[0] = 0 and dp[1] = 1. Then, we iteratively calculate Fibonacci values from dp[2] to dp[n] by using the relation dp[i] = dp[i-1] + dp[i-2]. This allows us to efficiently compute Fibonacci numbers in a loop. Finally, the value at dp[n] gives the Fibonacci number for the input n, as each index holds the answer for its corresponding Fibonacci number.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Space Optimised Approach - O(n) Time and O(1) Space",
            "content": "In the above code, we can see that the current state of any fibonacci number depends only on the previous two values. So we do not need to store the whole table of size n+1 but instead of that we can only store the previous two values.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Common Algorithms that Use DP:",
            "content": "Longest Common Subsequence (LCS): This is used in day to day life to find difference between two files (diff utility)\nEdit Distance : Checks how close to strings are. Can we be useful in implementing Google's did you mean type feature.\nLongest Increasing Subsequence : There are plenty of variations of this problem that arise in real world.\nBellman–Ford Shortest Path: Finds the shortest path from a given source to all other vertices.\nFloyd Warshall : Finds shortest path from every pair of vertices.\nKnapsack Problem: Determines the maximum value of items that can be placed in a knapsack with a given capacity.\nMatrix Chain Multiplication: Optimizes the order of matrix multiplication to minimize the number of operations.\nFibonacci Sequence: Calculates the nth Fibonacci number.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Advantages of Dynamic Programming",
            "content": "Dynamic programming has a wide range of advantages, including:\nAvoids recomputing the same subproblems multiple times, leading to significant time savings.\nEnsures that the optimal solution is found by considering all possible combinations.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Applications of Dynamic Programming",
            "content": "Dynamic programming has a wide range of applications, including:\nOptimization: Knapsack problem, shortest path problem, maximum subarray problem\nComputer Science: Longest common subsequence, edit distance, string matching\nOperations Research: Inventory management, scheduling, resource allocation\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Characteristics of Dynamic Programming Algorithm",
            "content": "For any problem, if there is a simple recursive solution and a recursion tree has same recursive calls multiple times (or overlapping subproblems), we use DP.\nDP vs Plain Recursion\nDP vs Greedy\nTop 20 Dynamic programming interview questions\nHow to solve a Dynamic Programming Problem?\nDynamic programming\nPractice Problems on Dynamic Programming\nInterview series\n",
            "code_snippets": {
              "cpp": "// C++ program to find// fibonacci number using space optimised.#include <iostream>using namespace std;int fibo(int n) {      int prevPrev, prev, curr;    // Storing the independent values    prevPrev = 0;    prev = 1;    curr = 1;    // Using the bottom-up approach    for (int i = 2; i <= n; i++) {        curr = prev + prevPrev;        prevPrev = prev;        prev = curr;    }    return curr;}int main() {    int n = 5;    cout << fibo(n);    return 0;}",
              "c": "// C program to find// fibonacci number using space optimised.#include <stdio.h>int fibo(int n) {    int prevPrev, prev, curr;    // Storing the independent values    prevPrev = 0;    prev = 1;    curr = 1;    // Using the bottom-up approach    for (int i = 2; i <= n; i++) {        curr = prev + prevPrev;        prevPrev = prev;        prev = curr;    }    return curr;}int main() {    int n = 5;    printf(\"%d\", fibo(n));    return 0;}",
              "java": "// Java program to find// fibonacci number using space optimised.classGfG {    static int fibo(int n) {        int prevPrev, prev, curr;        // Storing the independent values        prevPrev = 0;        prev = 1;        curr = 1;        // Using the bottom-up approach        for (int i = 2; i <= n; i++) {            curr = prev + prevPrev;            prevPrev = prev;            prev = curr;        }        return curr;    }    public static void main(String[] args) {        int n = 5;        System.out.println(fibo(n));    }}",
              "python3": "# Python program to find# fibonacci number using space optimised.deffibo(n):prevPrev,prev,curr=0,1,1# Using the bottom-up approachforiinrange(2,n+1):curr=prev+prevPrevprevPrev=prevprev=currreturncurrn=5print(fibo(n))",
              "csharp": "// C# program to find// fibonacci number using space optimised.using System;class GfG {    static int Fibo(int n) {        int prevPrev = 0, prev = 1, curr = 1;        // Using the bottom-up approach        for (int i = 2; i <= n; i++) {            curr = prev + prevPrev;            prevPrev = prev;            prev = curr;        }        return curr;    }    static void Main() {        int n = 5;        Console.WriteLine(Fibo(n));    }}",
              "javascript": "// Javascript program to find// fibonacci number using space optimised.function fibo(n) {    let prevPrev = 0, prev = 1, curr = 1;    // Using the bottom-up approach    for (let i = 2; i <= n; i++) {        curr = prev + prevPrev;        prevPrev = prev;        prev = curr;    }    return curr;}let n = 5;console.log(fibo(n));"
            }
          }
        ]
      },
      {
        "subtopic_title": "Tabulation vs Memoization",
        "subtopic_url": "https://www.geeksforgeeks.org/tabulation-vs-memoizatation/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Memoization",
            "content": "Top-down approach\nStores the results of function calls in a table.\nRecursive implementation\nEntries are filled when needed.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Tabulation:",
            "content": "Bottom-up approach\nStores the results of subproblems in a table\nIterative implementation\nEntries are filled in a bottom-up manner from the smallest size to the final size.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation Analysis: Rod Cutting Problem",
            "content": "Given a rod of length n inches and an array price[]. price[i] denotes the value of a piece of length i. The task is to determine the maximum value obtainable by cutting up the rod and selling the pieces.\nExamples:\nInput: price[] =  [1, 5, 8, 9, 10, 17, 17, 20]\nOutput: 22\nExplanation:  The maximum obtainable value is 22 by cutting in two pieces of lengths 2 and 6, i.e., 5 + 17 = 22.\nInput : price[] =  [3, 5, 8, 9, 10, 17, 17, 20]\nOutput : 24\nExplanation : The maximum obtainable value is 24 by cutting the rod into 8 pieces of length 1, i.e, 8*price[1]= 8*3 = 24.\nInput : price[] =  [3]\nOutput : 3\nExplanation: There is only 1 way to pick a piece of length 1.\nIn the rod cutting problem, the goal is to determine the maximum profit that can be obtained by cutting a rod into smaller pieces and selling them, given a price list for each possible piece length. The approach involves considering all possible cuts for the rod and recursively calculating the maximum profit for each cut. For detailed explanation and approaches, refer to Rod Cutting.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Top-Down DP (Memoization",
            "content": "In this implementation of the rod cutting problem, memoization is used to optimize the recursive approach by storing the results of subproblems, avoiding redundant calculations.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Bottom-Up DP (Tabulation) - O(n^2) Time and O(n) Space",
            "content": "We iteratively calculate the maximum profit for each possible rod length. For each length i, we check all possible smaller cuts, update the profit by comparing the current maximum profit with the profit obtained by combining smaller cuts, and ultimately return the maximum profit for the entire rod.\nFrom the above two approaches, we can observe the following key differences:\n",
            "code_snippets": {
              "cpp": "// C++ program to find maximum// profit from rod of size n#include <bits/stdc++.h>using namespace std;int cutRod(vector<int> &price) {    int n = price.size();    vector<int> dp(price.size() + 1, 0);    // Find maximum value for all    // rod of length i.    for (int i = 1; i <= n; i++) {        for (int j = 1; j <= i; j++) {            dp[i] = max(dp[i], price[j - 1] + dp[i - j]);        }    }    return dp[n];}int main() {      vector<int> price = {1, 5, 8, 9, 10, 17, 17, 20};    cout << cutRod(price);    return 0;}",
              "java": "// Java program to find maximum// profit from rod of size n import java.util.*;classGfG {    static int cutRod(int[] price) {        int n = price.length;        int[] dp = new int[n + 1];        // Find maximum value for all         // rod of length i.        for (int i = 1; i <= n; i++) {            for (int j = 1; j <= i; j++) {                dp[i] = Math.max(dp[i], price[j - 1] + dp[i - j]);            }        }        return dp[n];    }    public static void main(String[] args) {        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};        System.out.println(cutRod(price));    }}",
              "python3": "# Python program to find maximum# profit from rod of size n defcutRod(price):n=len(price)dp=[0]*(n+1)# Find maximum value for all # rod of length i.foriinrange(1,n+1):forjinrange(1,i+1):dp[i]=max(dp[i],price[j-1]+dp[i-j])returndp[n]if__name__==\"__main__\":price=[1,5,8,9,10,17,17,20]print(cutRod(price))",
              "csharp": "// C# program to find maximum// profit from rod of size n using System;class GfG {    static int cutRod(int[] price) {        int n = price.Length;        int[] dp = new int[n + 1];        // Find maximum value for all         // rod of length i.        for (int i = 1; i <= n; i++) {            for (int j = 1; j <= i; j++) {                dp[i] = Math.Max(dp[i], price[j - 1] + dp[i - j]);            }        }        return dp[n];    }    static void Main(string[] args) {        int[] price = {1, 5, 8, 9, 10, 17, 17, 20};        Console.WriteLine(cutRod(price));    }}",
              "javascript": "// JavaScript program to find maximum// profit from rod of size n function cutRod(price) {    const n = price.length;    const dp = Array(n + 1).fill(0);    // Find maximum value for all     // rod of length i.    for (let i = 1; i <= n; i++) {        for (let j = 1; j <= i; j++) {            dp[i] = Math.max(dp[i], price[j - 1] + dp[i - j]);        }    }    return dp[n];}const price = [1, 5, 8, 9, 10, 17, 17, 20];console.log(cutRod(price));"
            }
          }
        ]
      },
      {
        "subtopic_title": "Steps to solve a Dynamic Programming Problem",
        "subtopic_url": "https://www.geeksforgeeks.org/solve-dynamic-programming-problem/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Steps to solve a Dynamic programming problem:",
            "content": "Identify if it is a Dynamic programming problem.\nDecide a state expression with the Least parameters.\nFormulate state and transition relationship.\nApply tabulation or memorization.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Step 1: How to classify a problem as a Dynamic Programming Problem?",
            "content": "Typically, all the problems that require maximizing or minimizing certain quantities or counting problems that say to count the arrangements under certain conditions or certain probability problems can be solved by using Dynamic Programming.\nAll dynamic programming problems satisfy the overlapping subproblems property and most of the classic Dynamic programming problems also satisfy the optimal substructure property. Once we observe these properties in a given problem be sure that it can be solved using Dynamic Programming.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Step 2: Deciding the state",
            "content": "Dynamic Programming problems are all about the state and its transition. This is the most basic step which must be done very carefully because the state transition depends on the choice of state definition you make.\nState:\nA state can be defined as the set of parameters that can uniquely identify a certain position or standing in the given problem. This set of parameters should be as small as possible to reduce state space.\nExample:\nLet’s take the classic Knapsack problem, where we need to maximize profit by selecting items within a weight limit. Here, we define our state using two parameters: index and weight (dp[index][weight]). Think of it like this: dp[3][10] would tell us “what’s the maximum profit we can make by choosing from the first 4 items (index 0 to 3) when our bag can hold 10 units of weight?” These two parameters (index and weight) work together to uniquely identify each subproblem we need to solve.\nJust like GPS coordinates need both latitude and longitude to pinpoint a location, our knapsack solution needs both the item range and remaining capacity to determine the optimal profit at each step.\nSo, our next step will be to find a relation between previous states to reach the current state.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Step 3: Formulating a relation among the states",
            "content": "This part is the hardest part of solving a Dynamic Programming problem and requires a lot of intuition, observation, and practice.\nExample:\nGiven 3 numbers {1, 3, 5}, The task is to tell the total number of ways we can form a number n using the sum of the given three numbers. (allowing repetitions and different arrangements).\nThe total number of ways to form 6 is: 8\n1 + 1 + 1 + 1 + 1 + 1\n1 + 1 + 1 + 3\n1 + 1 + 3 + 1\n1 + 3 + 1 + 1\n3 + 1 + 1 + 1\n3 + 3\n1 + 5\n5 + 1\nThe steps to solve the given problem will be:\nWe decide a state for the given problem. \nWe will take a parameter n to decide the state as it uniquely identifies any subproblem. \nDP state will look like state(n), state(n) means the total number of arrangements to form n by using {1, 3, 5} as elements. Derive a transition relation between any two states.\nNow, we need to compute state(n).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "How to Compute the state?",
            "content": "As we can only use 1, 3, or 5 to form a given number n. Let us assume that we know the result for n = 1, 2, 3, 4, 5, 6 \nLet us say we know the result for:\nstate (n = 1), state (n = 2), state (n = 3) ……… state (n = 6) \nNow, we wish to know the result of the state (n = 7). See, we can only add 1, 3, and 5. Now we can get a sum total of 7 in the following 3 ways:\n1) Adding 1 to all possible combinations of state (n = 6) \nEg : [(1 + 1 + 1 + 1 + 1 + 1) + 1] \n[(1 + 1 + 1 + 3) + 1] \n[(1 + 1 + 3 + 1) + 1] \n[(1 + 3 + 1 + 1) + 1] \n[(3 + 1 + 1 + 1) + 1] \n[(3 + 3) + 1] \n[(1 + 5) + 1] \n[(5 + 1) + 1] \n2) Adding 3 to all possible combinations of state (n = 4);\n[(1 + 1 + 1 + 1) + 3] \n[(1 + 3) + 3] \n[(3 + 1) + 3] \n3) Adding 5 to all possible combinations of state(n = 2) \n[(1 + 1) + 5]\n(Note how it sufficient to add only on the right-side – all the add-from-left-side cases are covered, either in the same state, or another, e.g. [1 + (1 + 1 + 1 + 3)]  is not needed in state (n=6) because it’s covered by state (n = 4) [(1 + 1 + 1 + 1) + 3])\nNow, think carefully and satisfy yourself that the above three cases are covering all possible ways to form a sum total of 7;\nTherefore, we can say that result for \nstate(7) = state (6) + state (4) + state (2) \nOR\nstate(7) = state (7-1) + state (7-3) + state (7-5)\nIn general, \nstate(n) = state(n-1) + state(n-3) + state(n-5)\nBelow is the implementation of the above approach:\nTime Complexity: O(3^n), As at every stage we need to take three decisions and the height of the tree will be of the order of n.\nAuxiliary Space: O(n), The extra space is used due to the recursion call stack.\nThe above code seems exponential as it is calculating the same state again and again. So, we just need to add memoization.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Step 4: Adding memoization or tabulation for the state",
            "content": "This is the easiest part of a dynamic programming solution. We just need to store the state answer so that the next time that state is required, we can directly use it from our memory.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Top-Down DP (Memoization)",
            "content": "We break down the problem into smaller subproblems, where each subproblem corresponds to finding the number of ways to form a sum for a smaller value of ‘n’. By utilizing previously computed results, we can avoid redundant calculations and build up the solution for larger values of ‘n’.\nTime Complexity: O(n), As at every stage we need to take three decisions and the height of the tree will be of the order of n.\nAuxiliary Space: O(n + n), The extra space is used due to the recursion call stack and memo array of size n+1 is used to store the results of subproblems.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Using Bottom-Up DP (Tabulation",
            "content": "We define a DP array where each element dp[i] represents the number of ways to form the sum ‘i’. Starting with the base case dp[0] = 1 (since there is exactly one way to form a sum of 0 – using no numbers), we iteratively calculate the number of ways to form each value from 1 to n.\nTime Complexity: O(n), As we just need to make 3n function calls and there will be no repetitive calculations as we are returning previously calculated results.\nAuxiliary Space: O(n), dp array of size n+1 is used to store the results of subproblems.\nPlease Refer to Tabulation vs Memoization to understand the difference between memoization and tabulation.\nDynamic Programming comes with lots of practice. One must try solving various classic DP problems that can be found here. You may check the below problems first and try solving them using the above-described steps:-\n",
            "code_snippets": {
              "cpp": "// C++ program to express// n as sum of 1, 3, 5.#include <bits/stdc++.h>using namespace std;// Returns the number of// arrangements to form 'n'int countWays(int n) {    vector<int> dp(n + 1);    dp[0] = 1;    for (int i = 1; i <= n; i++) {        dp[i] = 0;        if (i - 1 >= 0)            dp[i] += dp[i - 1];        if (i - 3 >= 0)            dp[i] += dp[i - 3];        if (i - 5 >= 0)            dp[i] += dp[i - 5];    }    return dp[n];}int main() {    int n = 7;    cout << countWays(n);}",
              "java": "// Java program to express// n as sum of 1, 3, 5.classGfG {    // Returns the number of     // arrangements to form 'n'     static int countWays(int n) {        int[] dp = new int[n + 1];        dp[0] = 1;        for (int i = 1; i <= n; i++) {            dp[i] = 0;            if (i - 1 >= 0) dp[i] += dp[i - 1];            if (i - 3 >= 0) dp[i] += dp[i - 3];            if (i - 5 >= 0) dp[i] += dp[i - 5];        }        return dp[n];    }    public static void main(String[] args) {        int n = 7;        System.out.println(countWays(n));    }}",
              "python3": "# Python program to express# n as sum of 1, 3, 5.# Returns the number of # arrangements to form 'n' defcountWays(n):dp=[0]*(n+1)dp[0]=1foriinrange(1,n+1):dp[i]=0ifi-1>=0:dp[i]+=dp[i-1]ifi-3>=0:dp[i]+=dp[i-3]ifi-5>=0:dp[i]+=dp[i-5]returndp[n]if__name__==\"__main__\":n=7print(countWays(n))",
              "csharp": "// C# program to express// n as sum of 1, 3, 5.using System;class GfG {    // Returns the number of     // arrangements to form 'n'     static int countWays(int n) {        int[] dp = new int[n + 1];        dp[0] = 1;        for (int i = 1; i <= n; i++) {            dp[i] = 0;            if (i - 1 >= 0) dp[i] += dp[i - 1];            if (i - 3 >= 0) dp[i] += dp[i - 3];            if (i - 5 >= 0) dp[i] += dp[i - 5];        }        return dp[n];    }    static void Main(string[] args) {        int n = 7;        Console.WriteLine(countWays(n));    }}",
              "javascript": "// JavaScript program to express// n as sum of 1, 3, 5.// Returns the number of // arrangements to form 'n' function countWays(n) {    let dp = new Array(n + 1).fill(0);    dp[0] = 1;    for (let i = 1; i <= n; i++) {        dp[i] = 0;        if (i - 1 >= 0) dp[i] += dp[i - 1];        if (i - 3 >= 0) dp[i] += dp[i - 3];        if (i - 5 >= 0) dp[i] += dp[i - 5];    }    return dp[n];}let n = 7;console.log(countWays(n));"
            }
          }
        ]
      }
    ]
  },
  {
    "topic_name": "22. Other Algorithms",
    "main_article_link": "https://www.geeksforgeeks.org/bitwise-algorithms/",
    "subtopics": [
      {
        "subtopic_title": "Introduction to Bitwise Algorithms - Data Structures and Algorithms Tutorial",
        "subtopic_url": "https://www.geeksforgeeks.org/introduction-to-bitwise-algorithms-data-structures-and-algorithms-tutorial/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "What is Bitwise Algorithms?",
            "content": "Bitwise algorithms refer to algorithms that perform operations on individual bits or bit patterns within computer data. These algorithms uses the binary representation of data and use the fundamental bitwise operations such as AND, OR, XOR, NOT, and bit shifting to manipulate and extract information from the data.\nBitwise algorithms are usually faster and use less memory than regular arithmetic operations because they work directly with the binary representation of data. This often leads to faster execution times and reduced memory usage.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise Operators / Basics of Bit manipulation",
            "content": "An algorithmic operation known as bit manipulation involves the manipulation of bits at the bit level (bitwise). Bit manipulation is all about these bitwise operations. They improve the efficiency of programs by being primitive, fast actions.\nThe computer uses this bit manipulation to perform operations like addition, subtraction, multiplication, and division are all done at the bit level. This operation is performed in the arithmetic logic unit (ALU) which is a part of a computer's CPU. Inside the ALU, all such mathematical operations are performed.\nThere are different bitwise operations used in bit manipulation. These bit operations operate on the individual bits of the bit patterns. Bit operations are fast and can be used in optimizing time complexity.\nThe main bitwise operators are:\nAND (&)\nOR (|)\nXOR (^)\nNOT (~)\nLeft Shift (<<)\nRight Shift (>>)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise AND Operator (&)",
            "content": "The bitwise AND operator is denoted using a single ampersand symbol, i.e. &. The & operator takes two equal-length bit patterns as parameters. The two-bit integers are compared. If the bits in the compared positions of the bit patterns are 1, then the resulting bit is 1. If not, it is 0.\nExample:\nTake two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y\nBitwise ANDof (7 & 4)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of AND operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise OR Operator (|)",
            "content": "The | Operator takes two equivalent length bit designs as boundaries; if the two bits in the looked-at position are 0, the next bit is zero. If not, it is 1.\nExample:\nTake two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise OR of both X, y\nBitwise OR of (7 | 4)\nExplanation: On the basis of truth table of bitwise OR operator we can conclude that the result of \n1 | 1  = 1\n1 | 0 = 1\n0 | 1 = 1\n0 | 0 = 0\nWe used the similar concept of bitwise operator that are show in the image.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of OR operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise XOR Operator (^)",
            "content": "The ^ operator (also known as the XOR operator) stands for Exclusive Or. Here, if bits in the compared position do not match their resulting bit is 1. i.e, The result of the bitwise XOR operator is 1 if the corresponding bits of two operands are opposite, otherwise 0.\nExample:\nTake two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y\nBitwise OR of (7 ^ 4)\nExplanation: On the basis of truth table of bitwise XOR operator we can conclude that the result of \n1 ^ 1  = 0\n1 ^ 0 = 1\n0 ^ 1 = 1\n0 ^ 0 = 0\nWe used the similar concept of bitwise operator that are show in the image.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of XOR operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise NOT Operator (!~)",
            "content": "All the above three bitwise operators are binary operators (i.e, requiring two operands in order to operate). Unlike other bitwise operators, this one requires only one operand to operate.\nThe bitwise Not Operator takes a single value and returns its one’s complement. The one’s complement of a binary number is obtained by toggling all bits in it, i.e, transforming the 0 bit to 1 and the 1 bit to 0.\nExample:\nTake two bit values X and Y, where X = 5= (101)2 . Take Bitwise NOT of X.\nExplanation: On the basis of truth table of bitwise NOT operator we can conclude that the result of \n~1  = 0\n~0 = 1\nWe used the similar concept of bitwise operator that are show in the image.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of NOT operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Left-Shift (<<)",
            "content": "The left shift operator is denoted by the double left arrow key (<<). The general syntax for left shift is shift-expression << k. The left-shift operator causes the bits in shift expression to be shifted to the left by the number of positions specified by k. The bit positions that the shift operation has vacated are zero-filled.\nNote: Every time we shift a number towards the left by 1 bit it multiply that number by 2.\nExample:\nInput: Left shift of 5 by 1.\nBinary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 1)\n Left shift of 5 by 1\nOutput: 10\nExplanation: All bit of 5 will be shifted by 1 to left side and this result in 010102, Which is equivalent to 10\nInput: Left shift of 5 by 2.\nBinary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 2)\nLeft shift of 5 by 2\nOutput: 20\nExplanation: All bit of 5 will be shifted by 1 to left side and this result in 101002, Which is equivalent to 20\nInput: Left shift of 5 by 3.\nBinary representation of 5 = 00101 and Left shift of 001012 by 1 (i.e, 00101 << 3)\nLeft shift of 5 by 3\nOutput: 40\nExplanation: All bit of 5 will be shifted by 1 to left side and this result in 010002, Which is equivalent to 40\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of Left shift operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Right-Shift (>>)",
            "content": "The right shift operator is denoted by the double right arrow key (>>). The general syntax for the right shift is \"shift-expression >> k\". The right-shift operator causes the bits in shift expression to be shifted to the right by the number of positions specified by k. For unsigned numbers, the bit positions that the shift operation has vacated are zero-filled. For signed numbers, the sign bit is used to fill the vacated bit positions. In other words, if the number is positive, 0 is used, and if the number is negative, 1 is used.\nNote: Every time we shift a number towards the right by 1 bit it divides that number by 2.\nExample:\nInput: Right shift of 5 by 1.\nBinary representation of 5 = 00101 and Right shift of 00101 by 1 (i.e, 00101 >> 1)\nRight shift of 5 by 1\nOutput: 2\nExplanation: All bit of 5 will be shifted by 1 to Rightside and this result in 00010 Which is equivalent to 2\nInput: Right shift of 5 by 2.\nBinary representation of 5 = 00101 and Right shift of 00101 by 2 (i.e, 00101 >> 2)\nRight shift of 5 by 2\nOutput: 1\nExplanation: All bit of 5 will be shifted by 2 to Right side and this result in 00001, Which is equivalent to 1\nInput: Right shift of 5 by 3.\nBinary representation of 5 = 00101 and Right shift of 00101 by 3 (i.e, 00101 >> 3)\nRight shift of 5 by 3\nOutput: 0\nExplanation: All bit of 5 will be shifted by 3 to Right side and this result in 00000, Which is equivalent to 0\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Implementation of Right shift operator:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Application of Bit Operators",
            "content": "Bit operations are used for the optimization of embedded systems.\nThe Exclusive-or operator can be used to confirm the integrity of a file, making sure it has not been corrupted, especially after it has been in transit.\nBitwise operations are used in Data encryption and compression.\nBits are used in the area of networking, framing the packets of numerous bits which are sent to another system generally through any type of serial interface.\nDigital Image Processors use bitwise operations to enhance image pixels and to extract different sections of a microscopic image.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Important Practice Problems on Bitwise Algorithm:",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1.",
            "content": "If we want to set a bit at nth position in the number 'num', it can be done using the 'OR' operator( | ).\nFirst, we left shift 1 to n position via (1<<n)\nThen, use the \"OR\" operator to set the bit at that position. \"OR\" operator is used because it will set the bit even if the bit is unset previously in the binary representation of the number 'num'.\nNote: If the bit would be already set then it would remain unchanged.\nBelow is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2.",
            "content": "Suppose we want to unset a bit at nth position in number 'num' then we have to do this with the help of \"AND\" (&) operator.\nFirst, we left shift '1' to n position via (1<<n) then we use bitwise NOT operator '~' to unset this shifted '1'.\nNow after clearing this left shifted '1' i.e making it to '0' we will 'AND'(&) with the number 'num' that will unset bit at nth position.\nBelow is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3.",
            "content": "Toggling means to turn bit 'on'(1) if it was 'off'(0) and to turn 'off'(0) if it was 'on'(1) previously. We will be using the 'XOR' operator here which is this '^'. The reason behind the 'XOR' operator is because of its properties.\nProperties of 'XOR' operator. \n1^1 = 0\n0^0 = 0\n1^0 = 1\n0^1 = 1\nIf two bits are different then the 'XOR' operator returns a set bit(1) else it returns an unset bit(0).\nBelow is the implementation:\nTime Complexity: O(1) \nAuxiliary Space: O(1)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4.",
            "content": "We used the left shift (<<) operation on 1 to shift the bits to nth position and then use the & operation with number given number, and check if it is not-equals to 0.\nBelow is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "5.",
            "content": "Below is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "6.",
            "content": "Below is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "7.",
            "content": "The  problem can be solved based on the following observations:\nSay x = n % 4. The XOR value depends on the value if x.\nIf, x = 0, then the answer is n.\n   x = 1, then answer is 1.\n   x = 2, then answer is n+1.\n   x = 3, then answer is 0.\nBelow is the implementation of the above approach.\nTime Complexity: O(1) \nAuxiliary Space: O(1)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "8.",
            "content": "This can be solved based on the following fact:\nIf a number N is a power of 2, then the bitwise AND of N and N-1 will be 0. But this will not work if N is 0. So just check these two conditions, if any of these two conditions is true.\nBelow is the implementation of the above approach.\nTime Complexity: O(1) \nAuxiliary Space: O(1)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "9.",
            "content": "Counting set bits means, counting total number of 1’s in the binary representation of an integer. For this problem we go through all the bits of given number and check whether it is set or not by performing AND operation (with 1).\nBelow is the implementation:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "10.",
            "content": "The idea is to unset the rightmost bit of number n and XOR the result with n. Then the rightmost set bit in n will be the position of the only set bit in the result. Note that if n is odd, we can directly return 1 as the first bit is always set for odd numbers.\nExample: \nThe number 20 in binary is 00010100, and the position of the rightmost set bit is 3.\n00010100    &               (n = 20)\n00010011                     (n-1 = 19)\n-------------------\n00010000    ^                (XOR result number with n)\n00010100\n-------------------\n00000100 ------->  rightmost set bit will tell us the position\nBelow is the implementation:\nBits manipulation (Important tactics)\nBitwise Hacks for Competitive Programming\nBit Tricks for Competitive Programming \nMore Practice Problems on Bitwise Algorithms\n",
            "code_snippets": {
              "cpp": "// Returns the position of the rightmost set bit of `n`int positionOfRightmostSetBit(int n){    // if the number is odd, return 1    if (n & 1) {        return 1;    }    // unset rightmost bit and xor with the number itself    n = n ^ (n & (n - 1));    // find the position of the only set bit in the result;    // we can directly return `log2(n) + 1` from the    // function    int pos = 0;    while (n) {        n = n >> 1;        pos++;    }    return pos;}",
              "java": "// Returns the position of the rightmost set bit of `n`public static int positionOfRightmostSetBit(int n){    // if the number is odd, return 1    if ((n & 1) != 0) {        return 1;    }    // unset rightmost bit and xor with the number itself    n = n ^ (n & (n - 1));    // find the position of the only set bit in the result;    // we can directly return `log2(n) + 1` from the    // function    int pos = 0;    while (n != 0) {        n = n >> 1;        pos++;    }    return pos;}",
              "python3": "defcountBits(n):# Initializing a variable count to 0count=0whilen:# If the last bit is 1, count will be incremented by 1 in this step.count+=n&1# Using the right shift operator. The bits will be shifted one position to the right.n>>=1returncount",
              "csharp": "// Returns the position of the rightmost set bit of `n`public static int positionOfRightmostSetBit(int n){    // if the number is odd, return 1    if ((n & 1) != 0) {        return 1;    }    // unset rightmost bit and xor with the number itself    n = n ^ (n & (n - 1));    // find the position of the only set bit in the result;    // we can directly return `log2(n) + 1` from the    // function    int pos = 0;    while (n != 0) {        n = n >> 1;        pos++;    }    return pos;}",
              "javascript": "// Returns the position of the rightmost set bit of `n`function positionOfRightmostSetBit( n){    // if the number is odd, return 1    if (n & 1) {        return 1;    }    // unset rightmost bit and xor with the number itself    n = n ^ (n & (n - 1));    // find the position of the only set bit in the result;    // we can directly return `log2(n) + 1` from the    // function    let pos = 0;    while (n) {        n = n >> 1;        pos++;    }    return pos;}",
              "python": "# Returns the position of the rightmost set bit of `n`defpositionOfRightmostSetBit(n):# if the number is odd, return 1ifn&1:return1# unset rightmost bit and xor with the number itselfn=n^(n&(n-1))# find the position of the only set bit in the result;# we can directly return `log2(n) + 1` from the functionpos=0whilen:n=n>>1pos=pos+1returnpos"
            }
          }
        ]
      },
      {
        "subtopic_title": "What is Endianness? Big-Endian & Little-Endian",
        "subtopic_url": "https://www.geeksforgeeks.org/little-and-big-endian-mystery/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "What is Endianness?",
            "content": "Endianness refers to the order in which bytes are arranged in memory. Different languages read their text in different orders. for example, English reads from left to right, while Arabic reads from right to left. Endianness works similarly for computers. If one computer reads bytes from left to right and another reads them from right to left, issues arise when these computers need to communicate.\nEndianness ensures that bytes in computer memory are read in a specific order. Each computer system is internally consistent with its own data, but the advent of the internet has led to more data sharing than ever before, and not all systems read data in the same order.\nEndianness comes in two primary forms: Big-endian (BE) and Little-endian (LE).\nBig-endian (BE): Stores the most significant byte (the “big end”) first. This means that the first byte (at the lowest memory address) is the largest, which makes the most sense to people who read left to right.\nLittle-endian (LE): Stores the least significant byte (the “little end”) first. This means that the first byte (at the lowest memory address) is the smallest, which makes the most sense to people who read right to left.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is Big-endian?",
            "content": "In a big-endian system, the most significant byte (MSB) is stored at the lowest memory address. This means the “big end” (the most significant part of the data) comes first. For instance, a 32-bit integer 0x12345678 would be stored in memory as follows in a big-endian system:\nHere, 0x12 is the most significant byte, placed at the lowest address (00), followed by 0x34, 0x56, and 0x78 at the highest address (03).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "What is Little-endian?",
            "content": "A little-endian system stores the least significant byte (LSB) at the lowest memory address. The “little end” (the least significant part of the data) comes first. For the same 32-bit integer 0x12345678, a little-endian system would store it as:\nHere, 0x78 is the least significant byte, placed at the lowest address (00), followed by 0x56, 0x34, and 0x12 at the highest address (03).\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Significance of Most Significant Byte (MSbyte) in Little and Big Endian:",
            "content": "Understanding the concept of the Most Significant Byte (MSbyte) helps clarify endianness further. Let’s use a decimal number to illustrate.\nConsider the decimal number 2,984. Changing the digit 4 to 5 increases the number by 1, while changing the digit 2 to 3 increases the number by 1,000. This concept applies to bytes and bits as well.\nMost Significant Byte (MSbyte): The byte that holds the highest position value.\nLeast Significant Byte (LSbyte): The byte that holds the lowest position value.\nIn big-endian format, the MSbyte is stored first. In little-endian format, the MSbyte is stored last.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "When Might Endianness Be an Issue?",
            "content": "Endianness must be considered in various computing scenarios, particularly when systems with different byte orders need to communicate or share data.\nUnicode Characters: Unicode, the character set used universally across devices, uses a special character byte sequence called the Byte Order Mark (BOM). The BOM informs the system that the incoming stream is Unicode, specifies which Unicode character encoding is used, and indicates the endian order of the incoming stream.\nProgramming Languages: Some programming languages require specifying the byte order sequence. For instance, in Swift, used for iOS development, you can define whether data is stored in big-endian or little-endian format.\nNetwork Protocols: Different protocols have emerged historically, leading to the need for interaction. Big-endian is the dominant order in network protocols and is referred to as network order. Conversely, most PCs use little-endian format. Ensuring interoperability between these formats is critical in network communication.\nProcessor Design: Processors can be designed to be either little-endian, big-endian, or bi-endian (capable of handling both). Consumer choice and the resulting market trends have influenced what is considered “normal” in computer systems today.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Why is Endianness an Issue?",
            "content": "Endianness becomes an issue primarily due to the interaction between different systems and protocols. Historical protocol development led to varying byte order conventions, necessitating data conversion for compatibility. In higher-level languages and abstracted environments, endianness is often managed behind the scenes, reducing the need for developer concern. However, understanding endianness remains crucial for low-level programming, network protocol design, and data interoperability.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Conclusion",
            "content": "Endianness is how bytes are ordered in computer data. Big-endian and little-endian are two ways to arrange bytes, each with advantages. Understanding endianness is very important for developers dealing with low-level data, networking, and system interoperability. While little-endian is common, both formats remain important as technology evolves. Strategies for managing data across endian conventions will continue developing to ensure compatibility and performance.\n",
            "code_snippets": {
              "cpp": "Address:   00   01   02   03Data:        78   56   34   12"
            }
          }
        ]
      },
      {
        "subtopic_title": "JavaScript Bitwise Operators",
        "subtopic_url": "https://www.geeksforgeeks.org/javascript-bitwise-operators/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "List of Bitwise Operators with Explanation",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Bitwise AND Operator ( & )",
            "content": "It is a binary operator i.e. accepts two operands. Bit-wise AND (&) returns 1 if both the bits are set ( i.e 1) and 0 in any other case.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Bitwise OR Operator ( | )",
            "content": "It is a binary operator i.e. accepts two operands. Bit-wise OR ( | ) returns 1 if any of the operands is set (i.e. 1) and 0 in any other case.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Bitwise XOR Operator ( ^ )",
            "content": "It is a binary operator i.e. accepts two operands. Bit-wise XOR ( ^ ) returns 1 if both the operands are different and 0 in any other case.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Bitwise NOT Operator ( ~ )",
            "content": "It is a unary operator i.e. accepts single operands. Bit-wise NOT ( ~ ) flips the bits i.e 0 becomes 1 and 1 becomes 0.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "5. Left Shift Operator ( << )",
            "content": "It's a binary operator i.e. it accepts two operands. The first operator specifies the number and the second operator specifies the number of bits to shift. Each bit is shifted towards the left and 0 bits are added from the right. The excess bits from the left are discarded.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "6. Sign Propagating Right Shift Operator ( >> )",
            "content": "It's a binary operator i.e. it accepts two operands. The first operand specifies the number and the second operand specifies the number of bits to shift. Each bit is shifted towards the right, the overflowing bits are discarded. This is Sign Propagating as the bits are added from the left depending upon the sign of the number (i.e. 0 if positive and 1 if negative )\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "7. Zero Fill Right Shift Operator ( >>> )",
            "content": "It's a binary operator i.e. it accepts two operands. The first operand specifies the number and the second operand specifies the number of bits to shift. Each bit is shifted towards the right, the overflowing bits are discarded. 0 bit is added from the left so its zero fill right shift.\nRecommended Links\nJavaScript Operators Complete Reference  \nJavaScript Cheat Sheet.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Summary",
            "content": "",
            "code_snippets": {
              "javascript": "let a = 4; let b = -1 console.log(a >>> 1); console.log(b >>> 4);"
            }
          }
        ]
      },
      {
        "subtopic_title": "Bitwise Operators in C",
        "subtopic_url": "https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Example of Bitwise Operators in C",
            "content": "The following program uses bitwise operators to perform bit operations in C.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Interesting Facts About Bitwise Operators",
            "content": "1. The left-shift and right-shift operators should not be used for negative numbers.\nIf the second operand (which decides the number of shifts) is a negative number, it results in undefined behavior in C. For example, results of both 1 <<- 1 and 1 >> -1 are undefined. Also, if the number is shifted more than the size of the integer, the behavior is undefined. For example, 1 << 33 is undefined if integers are stored using 32 bits. Another thing is NO shift operation is performed if the additive expression (operand that decides no of shifts) is 0.\n2. The bitwise OR of two numbers is simply the sum of those two numbers if there is no carry involved; otherwise, you add their bitwise AND.\nLet’s say, we have a=5(101) and b=2(010), since there is no carry involved, their sum is just a|b. Now, if we change ‘b’ to 6 which is 110 in binary, their sum would change to a|b + a&b since there is a carry involved.\n3. The bitwise XOR operator is the most useful operator from a technical interview perspective.\nIt is used in many problems. A simple example could be \"Given a set of numbers where all elements occur an even number of times except one number, find the odd occurring number\" This problem can be efficiently solved by doing XOR to all numbers.\nExample\nBelow program demonstrates the use XOR operator to find odd occcuring elements in an array.\nThe following are many other interesting problems using the XOR operator.\nFind the Missing Number\nSwap two numbers without using a temporary variable\nA Memory-Efficient Doubly Linked List\nFind the two non-repeating elements\nFind the two numbers with odd occurrences in an unsorted array\nAdd two numbers without using arithmetic operators.\nSwap bits in a given number\nCount the number of bits to be flipped to convert a to b\nFind the element that appears once\nDetect if two integers have opposite signs\n4. The Bitwise operators should not be used in place of logical operators.\nThe result of logical operators (&&, || and !) is either 0 or 1, but bitwise operators return an integer value. Also, the logical operators consider any non-zero operand as 1. For example, consider the following program, the results of & and && are different for the same operands.\nExample:\n5. The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively.\nAs mentioned in point 1, it works only if numbers are positive.\nExample:\n6. The & operator can be used to quickly check if a number is odd or even.\nThe value of the expression (x & 1) would be non-zero only if x is odd, otherwise, the value would be zero.\nExample:\nThe below example demonstrates the use bitwise & operator to find if the given number is even or odd.\nTime Complexity: O(1)\nAuxiliary Space: O(1)\n7. The ~ operator should be used carefully.\nThe result of the ~ operator on a small number can be a big number if the result is stored in an unsigned variable. The result may be a negative number if the result is stored in a signed variable (assuming that the negative numbers are stored in 2's complement form where the leftmost bit is the sign bit).\nExample:\nNote The output of the above program is compiler dependent\n",
            "code_snippets": {
              "c": "#include <stdio.h>int main() {    unsigned int x = 1;    printf(\"Signed Result %d \\n\", ~x);    printf(\"Unsigned Result %u\", ~x);    return 0;}"
            }
          }
        ]
      },
      {
        "subtopic_title": "All about Bit Manipulation",
        "subtopic_url": "https://www.geeksforgeeks.org/all-about-bit-manipulation/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Get Bit:",
            "content": "This method is used to find the bit at a particular position(say i) of the given number N. The idea is to find the Bitwise AND of the given number and 2i that can be represented as (1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset.\nBelow is the pseudo-code for the same:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Set Bit:",
            "content": "This method is used to set the bit at a particular position(say i) of the given number N. The idea is to update the value of the given number N to the Bitwise OR of the given number N and 2i that can be represented as (1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset.\nBelow is the pseudo-code for the same:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Clear Bit:",
            "content": "This method is used to clear the bit at a particular position(say i) of the given number N. The idea is to update the value of the given number N to the Bitwise AND of the given number N and the compliment of 2i that can be represented as ~(1 << i). If the value return is 1 then the bit at the ith position is set. Otherwise, it is unset.\nBelow is the pseudo-code for the same:\nBelow is the program that implements the above functionalities:\nTime Complexity: O(1)\nAuxiliary Space: O(1)\nApplication of Bitwise Operator\nBitwise operations are prominent in embedded systems, control systems, etc where memory(data transmission/data points) is still an issue.\nThey are also useful in networking where it is important to reduce the amount of data, so booleans are packed together. Packing them together and taking them apart use bitwise operations and shift instructions.\nBitwise operations are also heavily used in the compression and encryption of data.\nUseful in graphics programming, older GUIs are heavily dependent on bitwise operations like XOR(^) for selection highlighting and other overlays.\n",
            "code_snippets": {
              "cpp": "// C++ program to implement all the// above functionalities#include <bits/stdc++.h>using namespace std;// Function to get the bit at the// ith positionbool getBit(int num, int i){    // Return true if the ith bit is    // set. Otherwise return false    return ((num & (1 << i)) != 0);}// Function to set the ith bit of the// given number numint setBit(int num, int i){    // Sets the ith bit and return    // the updated value    return num | (1 << i);}// Function to clear the ith bit of// the given number numint clearBit(int num, int i){    // Create the mask for the ith    // bit unset    int mask = ~(1 << i);    // Return the updated value    return num & mask;}// Driver Codeint main(){    // Given number N    int N = 70;    cout << \"The bit at the 3rd position from LSB is: \"         << (getBit(N, 3) ? '1' : '0')         << endl;    cout << \"The value of the given number \"         << \"after setting the bit at \"         << \"LSB is: \"         << setBit(N, 0) << endl;    cout << \"The value of the given number \"         << \"after clearing the bit at \"         << \"LSB is: \"         << clearBit(N, 0) << endl;    return 0;}",
              "java": "// Java program to implement all the// above functionalitiesimport java.io.*;classGFG{// Function to get the bit at the// ith positionstatic boolean getBit(int num, int i){        // Return true if the ith bit is    // set. Otherwise return false    return ((num & (1 << i)) != 0);}// Function to set the ith bit of the// given number numstatic int setBit(int num, int i){        // Sets the ith bit and return    // the updated value    return num | (1 << i);}// Function to clear the ith bit of// the given number numstatic int clearBit(int num, int i){        // Create the mask for the ith    // bit unset    int mask = ~(1 << i);    // Return the updated value    return num & mask;}// Driver Codepublic static void main(String[] args){        // Given number N    int N = 70;    System.out.println(\"The bit at the 3rd position from LSB is: \" +                        (getBit(N, 3) ? '1' : '0'));    System.out.println(\"The value of the given number \" +                        \"after setting the bit at \" +                        \"LSB is: \" + setBit(N, 0));    System.out.println(\"The value of the given number \" +                        \"after clearing the bit at \" +                        \"LSB is: \" + clearBit(N, 0));}}// This code is contributed by souravmahato348",
              "python3": "# Function to clear the ith bit of# the given number numdefclearBit(num,i):# Create the mask for the ith# bit unsetmask=~(1<<i)# Return the updated valuereturnnum&mask# This code is contributed by subhammahato348",
              "csharp": "// C# program to implement all the// above functionalitiesusing System;class GFG {    // Function to get the bit at the    // ith position    static bool getBit(int num, int i)    {        // Return true if the ith bit is        // set. Otherwise return false        return ((num & (1 << i)) != 0);    }    // Function to set the ith bit of the    // given number num    static int setBit(int num, int i)    {        // Sets the ith bit and return        // the updated value        return num | (1 << i);    }    // Function to clear the ith bit of    // the given number num    static int clearBit(int num, int i)    {        // Create the mask for the ith        // bit unset        int mask = ~(1 << i);        // Return the updated value        return num & mask;    }    // Driver Code    public static void Main()    {        // Given number N        int N = 70;        Console.WriteLine(\"The bit at the 3rd position form LSB is: \"                          + (getBit(N, 3) ? '1' : '0'));        Console.WriteLine(\"The value of the given number \"                          + \"after setting the bit at \"                          + \"LSB is: \" + setBit(N, 0));        Console.WriteLine(\"The value of the given number \"                          + \"after clearing the bit at \"                          + \"LSB is: \" + clearBit(N, 0));    }}// This code is contributed by rishavmahato348.",
              "javascript": "<script>// Javascript program to implement all// the above functionalities// Function to get the bit at the// ith positionfunction getBit(num, i){        // Return true if the ith bit is    // set. Otherwise return false    return ((num & (1 << i)) != 0);}// Function to set the ith bit of the// given number numfunction setBit(num, i){        // Sets the ith bit and return    // the updated value    return num | (1 << i);}// Function to clear the ith bit of// the given number numfunction clearBit(num, i){    // Create the mask for the ith    // bit unset    let mask = ~(1 << i);    // Return the updated value    return num & mask;}// Driver code// Given number Nlet N = 70;document.write(\"The bit at the 3rd position from LSB is: \" +               (getBit(N, 3) ? '1' : '0') + \"</br>\");document.write(\"The value of the given number \" +                \"after setting the bit at \" +                \"LSB is: \" + setBit(N, 0) + \"</br>\");document.write(\"The value of the given number \" +                \"after clearing the bit at \" +                \"LSB is: \" + clearBit(N, 0) + \"</br>\");               // This code is contributed by divyeshrabadiya07</script>",
              "python": "# Python program to implement all the# above functionalities# Function to get the bit at the# ith positiondefgetBit(num,i):# Return true if the ith bit is# set. Otherwise return falsereturn((num&(1<<i))!=0)# Function to set the ith bit of the# given number numdefsetBit(num,i):# Sets the ith bit and return# the updated valuereturnnum|(1<<i)# Function to clear the ith bit of# the given number numdefclearBit(num,i):# Create the mask for the ith# bit unsetmask=~(1<<i)# Return the updated valuereturnnum&mask# Driver Code# Given number NN=70print\"The bit at the 3rd position from LSB is: \",1if(getBit(N,3))else'0'print\"The value of the given number\",\"after setting the bit at\",\"LSB is: \",setBit(N,0)print\"The value of the given number\",\"after clearing the bit at\",\"LSB is: \",clearBit(N,0)# This code is contributed by shivanisinghss2110"
            }
          }
        ]
      },
      {
        "subtopic_title": "Bitwise Operators in Java",
        "subtopic_url": "https://www.geeksforgeeks.org/bitwise-operators-in-java/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "What Are Bitwise Operators?",
            "content": "Bitwise operators works on individual bits as discussed above. It works with integer types (byte, short, int, long). When a bitwise operation is performed, each bit of the particular number is treated as an individual based on the operation.\nBelow are the main bitwise operators available in Java:\nNow, let's look at each one of the bitwise operators in Java:\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "1. Bitwise AND (&)",
            "content": "This operator is a binary operator, denoted by '&.' It returns bit by bit AND of input values, i.e., if both bits are 1, it gives 1, else it shows 0.\na = 5 = 0101 (In Binary)\nb = 7 = 0111 (In Binary)\n\nBitwise AND Operation of 5 and 7\n  0101\n& 0111\n ________\n  0101  = 5 (In decimal)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "2. Bitwise OR (|)",
            "content": "This operator is a binary operator, denoted by '|'. It returns bit by bit OR of input values, i.e., if either of the bits is 1, it gives 1, else it shows 0.\na = 5 = 0101 (In Binary)\nb = 7 = 0111 (In Binary)\n\nBitwise OR Operation of 5 and 7\n  0101\n| 0111\n ________\n  0111  = 7 (In decimal)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "",
            "content": "",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "3. Bitwise XOR (^)",
            "content": "This operator is a binary operator, denoted by '^.' It returns bit by bit XOR of input values, i.e., if corresponding bits are different, it gives 1, else it shows 0.\na = 5 = 0101 (In Binary)\nb = 7 = 0111 (In Binary)\n\nBitwise XOR Operation of 5 and 7\n  0101\n^ 0111\n ________\n  0010  = 2 (In decimal)\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "4. Bitwise Complement (~)",
            "content": "This operator is a unary operator, denoted by '~.' It returns the one's complement representation of the input value, i.e., with all bits inverted, which means it makes every 0 to 1, and every 1 to 0.\na = 5 = 0101 (In Binary)\n\nBitwise Complement Operation of 5 in java (8 bits)\n\n~ 00000101\n ________\n  11111010  = -6 (In decimal)\nExplanation: ~5 inverts bits to 11111111 11111111 11111111 11111010, which is -6 in two's complement form.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Twist in Bitwise Complement Operator in Java",
            "content": "The bitwise complement of 5 is 246 and The 2's complement of 246 is -6. Hence, the output is -6 instead of 246.\nbitwise complement of N = ~N (represented in 2's complement form)\n2'complement of ~N = -(~(~N)+1)  =  -(N+1).\nFor Example: The 2's complement of a number is equal to the complement of that number + 1 .\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise Operators with Binary Output",
            "content": "Example: Here is the Java program that shows the bitwise operations using binary strings.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bit-Shift Operators (Shift Operators)",
            "content": "Shift operators are used to shift the bits of a number left or right, thereby multiplying or dividing the number by two, respectively. They can be used when we have to multiply or divide a number by two.\nnumber shift_op number_of_places_to_shift;\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Types of Shift Operators",
            "content": "Shift Operators are further divided into 3 types. These are:\nSigned Right shift operator (>>)\nUnsigned Right shift operator (>>>)\nLeft shift operator(<<)\nNote: For more detail about the Shift Operators in Java, refer Shift Operator in Java.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Program to Implement all Bitwise Operators in Java for User Input",
            "content": "Input:\nOutput:\nExplanation:\nThis program prompts the user to enter two numbers, num1 and num2. It then performs the following bitwise operations using the &, |, ^, ~, <<, >>, and >>> operators:\nBitwise AND\nBitwise OR\nBitwise XOR\nBitwise NOT\nBitwise Left Shift\nBitwise Right Shift\nBitwise Zero Fill Right Shift\n",
            "code_snippets": {
              "Unknown": "Bitwise AND: 0\nBitwise OR: 12\nBitwise XOR: 12\nBitwise NOT: -5\nBitwise Left Shift: 16\nBitwise Right Shift: 1\nBitwise Unsigned Right Shift: 1"
            }
          },
          {
            "sub_subtopic_title": "Advantages",
            "content": "The advantages of using Bitwise Operators in Java are:\nBitwise operations are much faster than arithmetic operations as they operate directly on binary representations of numbers.\nBitwise operations can be used to store multiple values in a single variable, which can be useful when working with limited memory.\nBitwise operators allow for precise control over individual bits of a number, which can be useful in various applications such as cryptography, error detection, and compression.\nBitwise operations can simplify the code by reducing the number of conditional statements and loops required to perform certain tasks.\n",
            "code_snippets": {
              "java": "import java.util.Scanner;public classGeeks {    public static void main(String[] args) {        Scanner input = new Scanner(System.in);        System.out.print(\"Enter first number: \");        int num1 = input.nextInt();        System.out.print(\"Enter second number: \");        int num2 = input.nextInt();        System.out.println(\"Bitwise AND: \" + (num1 & num2));        System.out.println(\"Bitwise OR: \" + (num1 | num2));        System.out.println(\"Bitwise XOR: \" + (num1 ^ num2));        System.out.println(\"Bitwise NOT: \" + (~num1));        System.out.println(\"Bitwise Left Shift: \" + (num1 << 2));        System.out.println(\"Bitwise Right Shift: \" + (num1 >> 2));        System.out.println(\"Bitwise Unsigned Right Shift: \" + (num1 >>> 2));        input.close();    }}"
            }
          }
        ]
      },
      {
        "subtopic_title": "Python Bitwise Operators",
        "subtopic_url": "https://www.geeksforgeeks.org/python-bitwise-operators/",
        "sub_subtopics": [
          {
            "sub_subtopic_title": "Bitwise AND Operator",
            "content": "Python Bitwise AND (&) operator takes two equal-length bit patterns as parameters. The two-bit integers are compared. If the bits in the compared positions of the bit patterns are 1, then the resulting bit is 1. If not, it is 0.\nExample: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & y\nNote: Here, (111)2 represent binary number.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise OR Operator",
            "content": "The Python Bitwise OR (|) Operator takes two equivalent length bit designs as boundaries; if the two bits in the looked-at position are 0, the next bit is zero. If not, it is 1.\nExample: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise OR of both X, Y\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise XOR Operator",
            "content": "The Python Bitwise XOR (^) Operator also known as the exclusive OR operator, is used to perform the XOR operation on two operands. XOR stands for “exclusive or”, and it returns true if and only if exactly one of the operands is true. In the context of bitwise operations, it compares corresponding bits of two operands. If the bits are different, it returns 1; otherwise, it returns 0.\nExample: Take two bit values X and Y, where X = 7= (111)2 and Y = 4 = (100)2 . Take Bitwise and of both X & Y\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise NOT Operator",
            "content": "The preceding three bitwise operators are binary operators, necessitating two operands to function. However, unlike the others, this operator operates with only one operand.\nPython Bitwise Not (~) Operator works with a single value and returns its one’s complement. This means it toggles all bits in the value, transforming 0 bits to 1 and 1 bits to 0, resulting in the one’s complement of the binary number.\nExample: Take two bit values X and Y, where X = 5= (101)2 . Take Bitwise NOT of X.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise Shift",
            "content": "These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two.\n",
            "code_snippets": {}
          },
          {
            "sub_subtopic_title": "Bitwise Right Shift",
            "content": "Shifts the bits of the number to the right and fills 0 on voids left( fills 1 in the case of a negative number) as a result. Similar effect as of dividing the number with some power of two.\n",
            "code_snippets": {
              "Unknown": "Example 1:\na = 10 = 0000 1010 (Binary)\na >> 1 = 0000 0101 = 5\n\nExample 2:\na = -10 = 1111 0110 (Binary)\na >> 1 = 1111 1011 = -5"
            }
          },
          {
            "sub_subtopic_title": "Bitwise Left Shift",
            "content": "Shifts the bits of the number to the left and fills 0 on voids right as a result. Similar effect as of multiplying the number with some power of two.\n",
            "code_snippets": {
              "Unknown": "Example 1:\na = 5 = 0000 0101 (Binary)\na << 1 = 0000 1010 = 10\na << 2 = 0001 0100 = 20 \n\nExample 2:\nb = -10 = 1111 0110 (Binary)\nb << 1 = 1110 1100 = -20\nb << 2 = 1101 1000 = -40"
            }
          },
          {
            "sub_subtopic_title": "Bitwise Operator Overloading",
            "content": "Operator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because the ‘+’ operator is overloaded by int class and str class. You might have noticed that the same built-in operator or function shows different behavior for objects of different classes, this is called Operator Overloading.\nBelow is a simple example of Bitwise operator overloading.\nNote: To know more about operator overloading click here.\n",
            "code_snippets": {
              "python3": "# Python program to demonstrate# operator overloadingclassGeek():def__init__(self,value):self.value=valuedef__and__(self,obj):print(\"And operator overloaded\")ifisinstance(obj,Geek):returnself.value&obj.valueelse:raiseValueError(\"Must be a object of class Geek\")def__or__(self,obj):print(\"Or operator overloaded\")ifisinstance(obj,Geek):returnself.value|obj.valueelse:raiseValueError(\"Must be a object of class Geek\")def__xor__(self,obj):print(\"Xor operator overloaded\")ifisinstance(obj,Geek):returnself.value^obj.valueelse:raiseValueError(\"Must be a object of class Geek\")def__lshift__(self,obj):print(\"lshift operator overloaded\")ifisinstance(obj,Geek):returnself.value<<obj.valueelse:raiseValueError(\"Must be a object of class Geek\")def__rshift__(self,obj):print(\"rshift operator overloaded\")ifisinstance(obj,Geek):returnself.value>>obj.valueelse:raiseValueError(\"Must be a object of class Geek\")def__invert__(self):print(\"Invert operator overloaded\")return~self.value# Driver's codeif__name__==\"__main__\":a=Geek(10)b=Geek(12)print(a&b)print(a|b)print(a^b)print(a<<b)print(a>>b)print(~a)"
            }
          }
        ]
      }
    ]
  }
]